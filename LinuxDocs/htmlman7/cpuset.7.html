<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <title>
   cpuset(7) &mdash; Linux manual pages
  </title>
  <link href="../stylesheet/manpages.css" rel="stylesheet" type="text/css"/>
  <link href="../index.html" rel="home" title="cpuset(7) &mdash; Linux manual pages"/>
  <script src="../stylesheet/manpages.js" type="text/javascript" xml:space="preserve">
  </script>
  <link href="../stylesheet/icon.gif" rel="icon" type="image/gif"/>
 </head>
 <body>
  <div class="refentry">
   <a id="cpuset.7" name="cpuset.7" shape="rect">
   </a>
   <div class="titlepage">
   </div>
   <div class="refnamediv">
    <h2>
     Name
    </h2>
    <p>
     cpuset &mdash; confine processes to processor and memory
      node subsets
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect1" name="cpuset-7_sect1" shape="rect">
    </a>
    <h2>
     DESCRIPTION
    </h2>
    <p>
     The cpuset filesystem is a pseudo-filesystem interface to
      the kernel cpuset mechanism, which is used to control the
      processor placement and memory placement of processes. It is
      commonly mounted at
     <code class="filename">
      /dev/cpuset
     </code>
     .
    </p>
    <p>
     On systems with kernels compiled with built in support for
      cpusets, all processes are attached to a cpuset, and cpusets
      are always present. If a system supports cpusets, then it
      will have the entry
     <span class="emphasis">
      <em>
       nodev
      cpuset
      </em>
     </span>
     in the file
     <code class="filename">
      /proc/filesystems
     </code>
     . By mounting the cpuset
      filesystem (see the
     <code class="constant">
      EXAMPLE
     </code>
     section below), the administrator can configure the cpusets
      on a system to control the processor and memory placement of
      processes on that system. By default, if the cpuset
      configuration on a system is not modified or if the cpuset
      filesystem is not even mounted, then the cpuset mechanism,
      though present, has no affect on the system's behavior.
    </p>
    <p>
     A cpuset defines a list of CPUs and memory nodes.
    </p>
    <p>
     The CPUs of a system include all the logical processing
      units on which a process can execute, including, if present,
      multiple processor cores within a package and Hyper-Threads
      within a processor core. Memory nodes include all distinct
      banks of main memory; small and SMP systems typically have
      just one memory node that contains all the system's main
      memory, while NUMA (non-uniform memory access) systems have
      multiple memory nodes.
    </p>
    <p>
     Cpusets are represented as directories in a hierarchical
      pseudo-filesystem, where the top directory in the hierarchy
      (
     <code class="filename">
      /dev/cpuset
     </code>
     ) represents the
      entire system (all online CPUs and memory nodes) and any
      cpuset that is the child (descendant) of another parent
      cpuset contains a subset of that parent's CPUs and memory
      nodes. The directories and files representing cpusets have
      normal filesystem permissions.
    </p>
    <p>
     Every process in the system belongs to exactly one cpuset.
      A process is confined to run only on the CPUs in the cpuset
      it belongs to, and to allocate memory only on the memory
      nodes in that cpuset. When a process
     <a class="link" href="../htmlman2/fork.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        fork
       </span>
       (2)
      </span>
     </a>
     s, the child process
      is placed in the same cpuset as its parent. With sufficient
      privilege, a process may be moved from one cpuset to another
      and the allowed CPUs and memory nodes of an existing cpuset
      may be changed.
    </p>
    <p>
     When the system begins booting, a single cpuset is defined
      that includes all CPUs and memory nodes on the system, and
      all processes are in that cpuset. During the boot process, or
      later during normal system operation, other cpusets may be
      created, as subdirectories of this top cpuset, under the
      control of the system administrator, and processes may be
      placed in these other cpusets.
    </p>
    <p>
     Cpusets are integrated with the
     <a class="link" href="../htmlman2/sched_setaffinity.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sched_setaffinity
       </span>
       (2)
      </span>
     </a>
     scheduling affinity mechanism and the
     <a class="link" href="../htmlman2/mbind.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mbind
       </span>
       (2)
      </span>
     </a>
     and
     <a class="link" href="../htmlman2/set_mempolicy.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        set_mempolicy
       </span>
       (2)
      </span>
     </a>
     memory-placement mechanisms in the kernel. Neither of these
      mechanisms let a process make use of a CPU or memory node
      that is not allowed by that process's cpuset. If changes to a
      process's cpuset placement conflict with these other
      mechanisms, then cpuset placement is enforced even if it
      means overriding these other mechanisms. The kernel
      accomplishes this overriding by silently restricting the CPUs
      and memory nodes requested by these other mechanisms to those
      allowed by the invoking process's cpuset. This can result in
      these other calls returning an error, if for example, such a
      call ends up requesting an empty set of CPUs or memory nodes,
      after that request is restricted to the invoking process's
      cpuset.
    </p>
    <p>
     Typically, a cpuset is used to manage the CPU and
      memory-node confinement for a set of cooperating processes
      such as a batch scheduler job, and these other mechanisms are
      used to manage the placement of individual processes or
      memory regions within that set or job.
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect2" name="cpuset-7_sect2" shape="rect">
    </a>
    <h2>
     FILES
    </h2>
    <p>
     Each directory below
     <code class="filename">
      /dev/cpuset
     </code>
     represents a cpuset and
      contains a fixed set of pseudo-files describing the state of
      that cpuset.
    </p>
    <p>
     New cpusets are created using the
     <a class="link" href="../htmlman2/mkdir.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mkdir
       </span>
       (2)
      </span>
     </a>
     system call or the
     <a class="link" href="../htmlman1/mkdir.1.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mkdir
       </span>
       (1)
      </span>
     </a>
     command. The
      properties of a cpuset, such as its flags, allowed CPUs and
      memory nodes, and attached processes, are queried and
      modified by reading or writing to the appropriate file in
      that cpuset's directory, as listed below.
    </p>
    <p>
     The pseudo-files in each cpuset directory are
      automatically created when the cpuset is created, as a result
      of the
     <a class="link" href="../htmlman2/mkdir.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mkdir
       </span>
       (2)
      </span>
     </a>
     invocation. It is
      not possible to directly add or remove these
      pseudo-files.
    </p>
    <p>
     A cpuset directory that contains no child cpuset
      directories, and has no attached processes, can be removed
      using
     <a class="link" href="../htmlman2/rmdir.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        rmdir
       </span>
       (2)
      </span>
     </a>
     or
     <a class="link" href="../htmlman1/rmdir.1.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        rmdir
       </span>
       (1)
      </span>
     </a>
     . It is not
      necessary, or possible, to remove the pseudo-files inside the
      directory before removing it.
    </p>
    <p>
     The pseudo-files in each cpuset directory are small text
      files that may be read and written using traditional shell
      utilities such as
     <a class="link" href="../htmlman1/cat.1.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        cat
       </span>
       (1)
      </span>
     </a>
     , and
     <a class="link" href="../htmlman1/echo.1.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        echo
       </span>
       (1)
      </span>
     </a>
     , or from a program
      by using file I/O library functions or system calls, such as
     <a class="link" href="../htmlman2/open.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        open
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/read.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        read
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        write
       </span>
       (2)
      </span>
     </a>
     , and
     <a class="link" href="../htmlman2/close.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        close
       </span>
       (2)
      </span>
     </a>
     .
    </p>
    <p>
     The pseudo-files in a cpuset directory represent internal
      kernel state and do not have any persistent image on disk.
      Each of these per-cpuset files is listed and described
      below.
    </p>
    <div class="variablelist">
     <dl class="variablelist">
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          tasks
         </code>
        </em>
       </span>
      </dt>
      <dd>
       <p>
        List of the process IDs (PIDs) of the processes in
            that cpuset. The list is formatted as a series of ASCII
            decimal numbers, each followed by a newline. A process
            may be added to a cpuset (automatically removing it
            from the cpuset that previously contained it) by
            writing its PID to that cpuset's
        <em class="replaceable">
         <code>
          tasks
         </code>
        </em>
        file (with or
            without a trailing newline).
       </p>
       <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Warning">
         <tr>
          <td align="center" colspan="1" rowspan="2" valign="top" width="25">
           <img alt="[Warning]" src="../stylesheet/warning.png"/>
          </td>
          <th align="left" colspan="1" rowspan="1">
           Warning
          </th>
         </tr>
         <tr>
          <td align="left" colspan="1" rowspan="1" valign="top">
           <p>
            only one PID may be written to the
            <em class="replaceable">
             <code>
              tasks
             </code>
            </em>
            file at a time. If a string is written that
                    contains more than one PID, only the first one
                    will be used.
           </p>
          </td>
         </tr>
        </table>
       </div>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          notify_on_release
         </code>
        </em>
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), that cpuset will receive
            special handling after it is released, that is, after
            all processes cease using it (i.e., terminate or are
            moved to a different cpuset) and all child cpuset
            directories have been removed. See the
        <span class="emphasis">
         <em>
          Notify On Release
         </em>
        </span>
        section,
            below.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
       </span>
      </dt>
      <dd>
       <p>
        List of the physical numbers of the CPUs on which
            processes in that cpuset are allowed to execute. See
        <span class="emphasis">
         <em>
          List Format
         </em>
        </span>
        below for a description of the format of
        <em class="replaceable">
         <code>
          cpus
         </code>
        </em>
        .
       </p>
       <p>
        The CPUs allowed to a cpuset may be changed by
            writing a new list to its
        <em class="replaceable">
         <code>
          cpus
         </code>
        </em>
        file.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.cpu_exclusive
         </code>
        </em>
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), the cpuset has exclusive
            use of its CPUs (no sibling or cousin cpuset may
            overlap CPUs). By default this is off (0). Newly
            created cpusets also initially default this to off
            (0).
       </p>
       <p>
        Two cpusets are
        <em class="replaceable">
         <code>
          sibling
         </code>
        </em>
        cpusets if they
            share the same parent cpuset in the
        <code class="filename">
         /dev/cpuset
        </code>
        hierarchy. Two cpusets
            are
        <em class="replaceable">
         <code>
          cousin
         </code>
        </em>
        cpusets if neither is the ancestor of the other.
            Regardless of the
        <em class="replaceable">
         <code>
          cpu_exclusive
         </code>
        </em>
        setting,
            if one cpuset is the ancestor of another, and if both
            of these cpusets have nonempty
        <em class="replaceable">
         <code>
          cpus
         </code>
        </em>
        , then their
        <em class="replaceable">
         <code>
          cpus
         </code>
        </em>
        must
            overlap, because the
        <em class="replaceable">
         <code>
          cpus
         </code>
        </em>
        of any cpuset are
            always a subset of the
        <em class="replaceable">
         <code>
          cpus
         </code>
        </em>
        of its parent
            cpuset.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
       </span>
      </dt>
      <dd>
       <p>
        List of memory nodes on which processes in this
            cpuset are allowed to allocate memory. See
        <span class="emphasis">
         <em>
          List Format
         </em>
        </span>
        below for a
            description of the format of
        <em class="replaceable">
         <code>
          mems
         </code>
        </em>
        .
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.mem_exclusive
         </code>
        </em>
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), the cpuset has exclusive
            use of its memory nodes (no sibling or cousin may
            overlap). Also if set (1), the cpuset is a
        <em class="replaceable">
         <code>
          Hardwall
         </code>
        </em>
        cpuset (see
            below). By default this is off (0). Newly created
            cpusets also initially default this to off (0).
       </p>
       <p>
        Regardless of the
        <em class="replaceable">
         <code>
          mem_exclusive
         </code>
        </em>
        setting,
            if one cpuset is the ancestor of another, then their
            memory nodes must overlap, because the memory nodes of
            any cpuset are always a subset of the memory nodes of
            that cpuset's parent cpuset.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.mem_hardwall
         </code>
        </em>
        (since Linux 2.6.26)
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), the cpuset is a
        <em class="replaceable">
         <code>
          Hardwall
         </code>
        </em>
        cpuset (see below). Unlike
        <em class="replaceable">
         <code>
          mem_exclusive
         </code>
        </em>
        , there is
            no constraint on whether cpusets marked
        <em class="replaceable">
         <code>
          mem_hardwall
         </code>
        </em>
        may have
            overlapping memory nodes with sibling or cousin
            cpusets. By default this is off (0). Newly created
            cpusets also initially default this to off (0).
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.memory_migrate
         </code>
        </em>
        (since Linux 2.6.16)
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), then memory migration is
            enabled. By default this is off (0). See the
        <span class="emphasis">
         <em>
          Memory Migration
         </em>
        </span>
        section, below.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.memory_pressure
         </code>
        </em>
        (since Linux 2.6.16)
       </span>
      </dt>
      <dd>
       <p>
        A measure of how much memory pressure the processes
            in this cpuset are causing. See the
        <span class="emphasis">
         <em>
          Memory Pressure
         </em>
        </span>
        section,
            below. Unless
        <em class="replaceable">
         <code>
          memory_pressure_enabled
         </code>
        </em>
        is enabled, always has value zero (0). This file is
            read-only. See the
        <code class="constant">
         WARNINGS
        </code>
        section, below.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.memory_pressure_enabled
         </code>
        </em>
        (since Linux 2.6.16)
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). This file is present only in the root
            cpuset, normally
        <code class="filename">
         /dev/cpuset
        </code>
        . If set (1), the
        <em class="replaceable">
         <code>
          memory_pressure
         </code>
        </em>
        calculations are enabled for all cpusets in the system.
            By default this is off (0). See the
        <span class="emphasis">
         <em>
          Memory Pressure
         </em>
        </span>
        section,
            below.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.memory_spread_page
         </code>
        </em>
        (since Linux 2.6.17)
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), pages in the kernel page
            cache (filesystem buffers) are uniformly spread across
            the cpuset. By default this is off (0) in the top
            cpuset, and inherited from the parent cpuset in newly
            created cpusets. See the
        <span class="emphasis">
         <em>
          Memory Spread
         </em>
        </span>
        section,
            below.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.memory_spread_slab
         </code>
        </em>
        (since Linux 2.6.17)
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1), the kernel slab caches
            for file I/O (directory and inode structures) are
            uniformly spread across the cpuset. By default this is
            off (0) in the top cpuset, and inherited from the
            parent cpuset in newly created cpusets. See the
        <span class="emphasis">
         <em>
          Memory Spread
         </em>
        </span>
        section, below.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.sched_load_balance
         </code>
        </em>
        (since Linux 2.6.24)
       </span>
      </dt>
      <dd>
       <p>
        Flag (0 or 1). If set (1, the default) the kernel
            will automatically load balance processes in that
            cpuset over the allowed CPUs in that cpuset. If cleared
            (0) the kernel will avoid load balancing processes in
            this cpuset,
        <em class="replaceable">
         <code>
          unless
         </code>
        </em>
        some other
            cpuset with overlapping CPUs has its
        <em class="replaceable">
         <code>
          sched_load_balance
         </code>
        </em>
        flag
            set. See
        <span class="emphasis">
         <em>
          Scheduler Load
            Balancing
         </em>
        </span>
        , below, for further details.
       </p>
      </dd>
      <dt>
       <span class="term">
        <em class="replaceable">
         <code>
          cpuset.sched_relax_domain_level
         </code>
        </em>
        (since Linux 2.6.26)
       </span>
      </dt>
      <dd>
       <p>
        Integer, between &minus;1 and a small positive
            value. The
        <em class="replaceable">
         <code>
          sched_relax_domain_level
         </code>
        </em>
        controls the width of the range of CPUs over which the
            kernel scheduler performs immediate rebalancing of
            runnable tasks across CPUs. If
        <em class="replaceable">
         <code>
          sched_load_balance
         </code>
        </em>
        is
            disabled, then the setting of
        <em class="replaceable">
         <code>
          sched_relax_domain_level
         </code>
        </em>
        does not matter, as no such load balancing is done. If
        <em class="replaceable">
         <code>
          sched_load_balance
         </code>
        </em>
        is
            enabled, then the higher the value of the
        <em class="replaceable">
         <code>
          sched_relax_domain_level
         </code>
        </em>
        ,
            the wider the range of CPUs over which immediate load
            balancing is attempted. See
        <span class="emphasis">
         <em>
          Scheduler Relax Domain
            Level
         </em>
        </span>
        , below, for further details.
       </p>
      </dd>
     </dl>
    </div>
    <p>
     In addition to the above pseudo-files in each directory
      below
     <code class="filename">
      /dev/cpuset
     </code>
     , each process
      has a pseudo-file,
     <code class="filename">
      /proc/&lt;pid&gt;/cpuset
     </code>
     , that displays the
      path of the process's cpuset directory relative to the root
      of the cpuset filesystem.
    </p>
    <p>
     Also the
     <code class="filename">
      /proc/&lt;pid&gt;/status
     </code>
     file for each
      process has four added lines, displaying the process's
     <em class="replaceable">
      <code>
       Cpus_allowed
      </code>
     </em>
     (on
      which CPUs it may be scheduled) and
     <em class="replaceable">
      <code>
       Mems_allowed
      </code>
     </em>
     (on which memory
      nodes it may obtain memory), in the two formats
     <span class="emphasis">
      <em>
       Mask Format
      </em>
     </span>
     and
     <span class="emphasis">
      <em>
       List Format
      </em>
     </span>
     (see below) as shown
      in the following example:
    </p>
    <div class="blockquote">
     <blockquote class="blockquote">
      <div class="informalexample">
       <pre class="programlisting" xml:space="preserve">
Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff
Cpus_allowed_list:     0-127
Mems_allowed:   ffffffff,ffffffff
Mems_allowed_list:     0-63
</pre>
      </div>
     </blockquote>
    </div>
    <p>
     The "allowed" fields were added in Linux 2.6.24; the
      "allowed_list" fields were added in Linux 2.6.26.
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect3" name="cpuset-7_sect3" shape="rect">
    </a>
    <h2>
     EXTENDED CAPABILITIES
    </h2>
    <p>
     In addition to controlling which
     <em class="replaceable">
      <code>
       cpus
      </code>
     </em>
     and
     <em class="replaceable">
      <code>
       mems
      </code>
     </em>
     a process is allowed to
      use, cpusets provide the following extended capabilities.
    </p>
    <div class="refsect2">
     <a id="cpuset-7_sect4" name="cpuset-7_sect4" shape="rect">
     </a>
     <h3>
      Exclusive cpusets
     </h3>
     <p>
      If a cpuset is marked
      <em class="replaceable">
       <code>
        cpu_exclusive
       </code>
      </em>
      or
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      , no other
        cpuset, other than a direct ancestor or descendant, may
        share any of the same CPUs or memory nodes.
     </p>
     <p>
      A cpuset that is
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      restricts
        kernel allocations for buffer cache pages and other
        internal kernel data pages commonly shared by the kernel
        across multiple users. All cpusets, whether
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      or not,
        restrict allocations of memory for user space. This enables
        configuring a system so that several independent jobs can
        share common kernel data, while isolating each job's user
        allocation in its own cpuset. To do this, construct a large
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      cpuset to hold all the jobs, and construct child,
        non-
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      cpusets for each individual job. Only a small amount of
        kernel memory, such as requests from interrupt handlers, is
        allowed to be placed on memory nodes outside even a
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      cpuset.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect5" name="cpuset-7_sect5" shape="rect">
     </a>
     <h3>
      Hardwall
     </h3>
     <p>
      A cpuset that has
      <em class="replaceable">
       <code>
        mem_exclusive
       </code>
      </em>
      or
      <em class="replaceable">
       <code>
        mem_hardwall
       </code>
      </em>
      set is a
      <em class="replaceable">
       <code>
        hardwall
       </code>
      </em>
      cpuset.
        A
      <em class="replaceable">
       <code>
        hardwall
       </code>
      </em>
      cpuset
        restricts kernel allocations for page, buffer, and other
        data commonly shared by the kernel across multiple users.
        All cpusets, whether
      <em class="replaceable">
       <code>
        hardwall
       </code>
      </em>
      or not, restrict
        allocations of memory for user space.
     </p>
     <p>
      This enables configuring a system so that several
        independent jobs can share common kernel data, such as
        filesystem pages, while isolating each job's user
        allocation in its own cpuset. To do this, construct a large
      <em class="replaceable">
       <code>
        hardwall
       </code>
      </em>
      cpuset
        to hold all the jobs, and construct child cpusets for each
        individual job which are not
      <em class="replaceable">
       <code>
        hardwall
       </code>
      </em>
      cpusets.
     </p>
     <p>
      Only a small amount of kernel memory, such as requests
        from interrupt handlers, is allowed to be taken outside
        even a
      <em class="replaceable">
       <code>
        hardwall
       </code>
      </em>
      cpuset.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect6" name="cpuset-7_sect6" shape="rect">
     </a>
     <h3>
      Notify on release
     </h3>
     <p>
      If the
      <em class="replaceable">
       <code>
        notify_on_release
       </code>
      </em>
      flag is
        enabled (1) in a cpuset, then whenever the last process in
        the cpuset leaves (exits or attaches to some other cpuset)
        and the last child cpuset of that cpuset is removed, the
        kernel will run the command
      <code class="filename">
       /sbin/cpuset_release_agent
      </code>
      , supplying the
        pathname (relative to the mount point of the cpuset
        filesystem) of the abandoned cpuset. This enables automatic
        removal of abandoned cpusets.
     </p>
     <p>
      The default value of
      <em class="replaceable">
       <code>
        notify_on_release
       </code>
      </em>
      in the
        root cpuset at system boot is disabled (0). The default
        value of other cpusets at creation is the current value of
        their parent's
      <em class="replaceable">
       <code>
        notify_on_release
       </code>
      </em>
      setting.
     </p>
     <p>
      The command
      <code class="filename">
       /sbin/cpuset_release_agent
      </code>
      is invoked,
        with the name (
      <code class="filename">
       /dev/cpuset
      </code>
      relative path) of the to-be-released cpuset in
      <em class="replaceable">
       <code>
        argv[1]
       </code>
      </em>
      .
     </p>
     <p>
      The usual contents of the command
      <code class="filename">
       /sbin/cpuset_release_agent
      </code>
      is simply the
        shell script:
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
#!/bin/sh
rmdir /dev/cpuset/$1
</pre>
       </div>
      </blockquote>
     </div>
     <p>
      As with other flag values below, this flag can be
        changed by writing an ASCII number 0 or 1 (with optional
        trailing newline) into the file, to clear or set the flag,
        respectively.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect7" name="cpuset-7_sect7" shape="rect">
     </a>
     <h3>
      Memory pressure
     </h3>
     <p>
      The
      <em class="replaceable">
       <code>
        memory_pressure
       </code>
      </em>
      of a cpuset
        provides a simple per-cpuset running average of the rate
        that the processes in a cpuset are attempting to free up
        in-use memory on the nodes of the cpuset to satisfy
        additional memory requests.
     </p>
     <p>
      This enables batch managers that are monitoring jobs
        running in dedicated cpusets to efficiently detect what
        level of memory pressure that job is causing.
     </p>
     <p>
      This is useful both on tightly managed systems running a
        wide mix of submitted jobs, which may choose to terminate
        or reprioritize jobs that are trying to use more memory
        than allowed on the nodes assigned them, and with tightly
        coupled, long-running, massively parallel scientific
        computing jobs that will dramatically fail to meet required
        performance goals if they start to use more memory than
        allowed to them.
     </p>
     <p>
      This mechanism provides a very economical way for the
        batch manager to monitor a cpuset for signs of memory
        pressure. It's up to the batch manager or other user code
        to decide what action to take if it detects signs of memory
        pressure.
     </p>
     <p>
      Unless memory pressure calculation is enabled by setting
        the pseudo-file
      <code class="filename">
       /dev/cpuset/cpuset.memory_pressure_enabled
      </code>
      ,
        it is not computed for any cpuset, and reads from any
      <em class="replaceable">
       <code>
        memory_pressure
       </code>
      </em>
      always return zero, as represented by the ASCII string
        "0\n". See the
      <code class="constant">
       WARNINGS
      </code>
      section, below.
     </p>
     <p>
      A per-cpuset, running average is employed for the
        following reasons:
     </p>
     <div class="itemizedlist">
      <ul class="itemizedlist" style="list-style-type: disc;">
       <li class="listitem">
        <p>
         Because this meter is per-cpuset rather than
              per-process or per virtual memory region, the system
              load imposed by a batch scheduler monitoring this
              metric is sharply reduced on large systems, because a
              scan of the tasklist can be avoided on each set of
              queries.
        </p>
       </li>
       <li class="listitem">
        <p>
         Because this meter is a running average rather
              than an accumulating counter, a batch scheduler can
              detect memory pressure with a single read, instead of
              having to read and accumulate results for a period of
              time.
        </p>
       </li>
       <li class="listitem">
        <p>
         Because this meter is per-cpuset rather than
              per-process, the batch scheduler can obtain the key
              information&mdash;memory pressure in a
              cpuset&mdash;with a single read, rather than having
              to query and accumulate results over all the
              (dynamically changing) set of processes in the
              cpuset.
        </p>
       </li>
      </ul>
     </div>
     <p>
      The
      <em class="replaceable">
       <code>
        memory_pressure
       </code>
      </em>
      of a cpuset
        is calculated using a per-cpuset simple digital filter that
        is kept within the kernel. For each cpuset, this filter
        tracks the recent rate at which processes attached to that
        cpuset enter the kernel direct reclaim code.
     </p>
     <p>
      The kernel direct reclaim code is entered whenever a
        process has to satisfy a memory page request by first
        finding some other page to repurpose, due to lack of any
        readily available already free pages. Dirty filesystem
        pages are repurposed by first writing them to disk.
        Unmodified filesystem buffer pages are repurposed by simply
        dropping them, though if that page is needed again, it will
        have to be reread from disk.
     </p>
     <p>
      The
      <em class="replaceable">
       <code>
        cpuset.memory_pressure
       </code>
      </em>
      file
        provides an integer number representing the recent
        (half-life of 10 seconds) rate of entries to the direct
        reclaim code caused by any process in the cpuset, in units
        of reclaims attempted per second, times 1000.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect8" name="cpuset-7_sect8" shape="rect">
     </a>
     <h3>
      Memory spread
     </h3>
     <p>
      There are two Boolean flag files per cpuset that control
        where the kernel allocates pages for the filesystem buffers
        and related in-kernel data structures. They are called
      <em class="replaceable">
       <code>
        cpuset.memory_spread_page
       </code>
      </em>
      and
      <em class="replaceable">
       <code>
        cpuset.memory_spread_slab
       </code>
      </em>
      .
     </p>
     <p>
      If the per-cpuset Boolean flag file
      <em class="replaceable">
       <code>
        cpuset.memory_spread_page
       </code>
      </em>
      is set, then the kernel will spread the filesystem buffers
        (page cache) evenly over all the nodes that the faulting
        process is allowed to use, instead of preferring to put
        those pages on the node where the process is running.
     </p>
     <p>
      If the per-cpuset Boolean flag file
      <em class="replaceable">
       <code>
        cpuset.memory_spread_slab
       </code>
      </em>
      is set, then the kernel will spread some filesystem-related
        slab caches, such as those for inodes and directory
        entries, evenly over all the nodes that the faulting
        process is allowed to use, instead of preferring to put
        those pages on the node where the process is running.
     </p>
     <p>
      The setting of these flags does not affect the data
        segment (see
      <a class="link" href="../htmlman2/brk.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         brk
        </span>
        (2)
       </span>
      </a>
      ) or stack segment
        pages of a process.
     </p>
     <p>
      By default, both kinds of memory spreading are off and
        the kernel prefers to allocate memory pages on the node
        local to where the requesting process is running. If that
        node is not allowed by the process's NUMA memory policy or
        cpuset configuration or if there are insufficient free
        memory pages on that node, then the kernel looks for the
        nearest node that is allowed and has sufficient free
        memory.
     </p>
     <p>
      When new cpusets are created, they inherit the memory
        spread settings of their parent.
     </p>
     <p>
      Setting memory spreading causes allocations for the
        affected page or slab caches to ignore the process's NUMA
        memory policy and be spread instead. However, the effect of
        these changes in memory placement caused by
        cpuset-specified memory spreading is hidden from the
      <a class="link" href="../htmlman2/mbind.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         mbind
        </span>
        (2)
       </span>
      </a>
      or
      <a class="link" href="../htmlman2/set_mempolicy.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         set_mempolicy
        </span>
        (2)
       </span>
      </a>
      calls.
        These two NUMA memory policy calls always appear to behave
        as if no cpuset-specified memory spreading is in effect,
        even if it is. If cpuset memory spreading is subsequently
        turned off, the NUMA memory policy most recently specified
        by these calls is automatically reapplied.
     </p>
     <p>
      Both
      <em class="replaceable">
       <code>
        cpuset.memory_spread_page
       </code>
      </em>
      and
      <em class="replaceable">
       <code>
        cpuset.memory_spread_slab
       </code>
      </em>
      are Boolean flag files. By default they contain "0",
        meaning that the feature is off for that cpuset. If a "1"
        is written to that file, that turns the named feature
        on.
     </p>
     <p>
      Cpuset-specified memory spreading behaves similarly to
        what is known (in other contexts) as round-robin or
        interleave memory placement.
     </p>
     <p>
      Cpuset-specified memory spreading can provide
        substantial performance improvements for jobs that:
     </p>
     <div class="orderedlist">
      <ol class="orderedlist" type="a">
       <li class="listitem">
        <p>
         need to place thread-local data on memory nodes
              close to the CPUs which are running the threads that
              most frequently access that data; but also
        </p>
       </li>
       <li class="listitem">
        <p>
         need to access large filesystem data sets that
              must to be spread across the several nodes in the
              job's cpuset in order to fit.
        </p>
       </li>
      </ol>
     </div>
     <p>
      Without this policy, the memory allocation across the
        nodes in the job's cpuset can become very uneven,
        especially for jobs that might have just a single thread
        initializing or reading in the data set.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect9" name="cpuset-7_sect9" shape="rect">
     </a>
     <h3>
      Memory migration
     </h3>
     <p>
      Normally, under the default setting (disabled) of
      <em class="replaceable">
       <code>
        cpuset.memory_migrate
       </code>
      </em>
      , once
        a page is allocated (given a physical page of main memory),
        then that page stays on whatever node it was allocated, so
        long as it remains allocated, even if the cpuset's
        memory-placement policy
      <em class="replaceable">
       <code>
        mems
       </code>
      </em>
      subsequently
        changes.
     </p>
     <p>
      When memory migration is enabled in a cpuset, if the
      <em class="replaceable">
       <code>
        mems
       </code>
      </em>
      setting of
        the cpuset is changed, then any memory page in use by any
        process in the cpuset that is on a memory node that is no
        longer allowed will be migrated to a memory node that is
        allowed.
     </p>
     <p>
      Furthermore, if a process is moved into a cpuset with
      <em class="replaceable">
       <code>
        memory_migrate
       </code>
      </em>
      enabled, any memory pages it uses that were on memory nodes
        allowed in its previous cpuset, but which are not allowed
        in its new cpuset, will be migrated to a memory node
        allowed in the new cpuset.
     </p>
     <p>
      The relative placement of a migrated page within the
        cpuset is preserved during these migration operations if
        possible. For example, if the page was on the second valid
        node of the prior cpuset, then the page will be placed on
        the second valid node of the new cpuset, if possible.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect10" name="cpuset-7_sect10" shape="rect">
     </a>
     <h3>
      Scheduler load balancing
     </h3>
     <p>
      The kernel scheduler automatically load balances
        processes. If one CPU is underutilized, the kernel will
        look for processes on other more overloaded CPUs and move
        those processes to the underutilized CPU, within the
        constraints of such placement mechanisms as cpusets and
      <a class="link" href="../htmlman2/sched_setaffinity.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         sched_setaffinity
        </span>
        (2)
       </span>
      </a>
      .
     </p>
     <p>
      The algorithmic cost of load balancing and its impact on
        key shared kernel data structures such as the process list
        increases more than linearly with the number of CPUs being
        balanced. For example, it costs more to load balance across
        one large set of CPUs than it does to balance across two
        smaller sets of CPUs, each of half the size of the larger
        set. (The precise relationship between the number of CPUs
        being balanced and the cost of load balancing depends on
        implementation details of the kernel process scheduler,
        which is subject to change over time, as improved kernel
        scheduler algorithms are implemented.)
     </p>
     <p>
      The per-cpuset flag
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      provides
        a mechanism to suppress this automatic scheduler load
        balancing in cases where it is not needed and suppressing
        it would have worthwhile performance benefits.
     </p>
     <p>
      By default, load balancing is done across all CPUs,
        except those marked isolated using the kernel boot time
        "isolcpus=" argument. (See
      <span class="emphasis">
       <em>
        Scheduler Relax Domain Level
       </em>
      </span>
      ,
        below, to change this default.)
     </p>
     <p>
      This default load balancing across all CPUs is not well
        suited to the following two situations:
     </p>
     <div class="itemizedlist">
      <ul class="itemizedlist" style="list-style-type: disc;">
       <li class="listitem">
        <p>
         On large systems, load balancing across many CPUs
              is expensive. If the system is managed using cpusets
              to place independent jobs on separate sets of CPUs,
              full load balancing is unnecessary.
        </p>
       </li>
       <li class="listitem">
        <p>
         Systems supporting real-time on some CPUs need to
              minimize system overhead on those CPUs, including
              avoiding process load balancing if that is not
              needed.
        </p>
       </li>
      </ul>
     </div>
     <p>
      When the per-cpuset flag
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      is
        enabled (the default setting), it requests load balancing
        across all the CPUs in that cpuset's allowed CPUs, ensuring
        that load balancing can move a process (not otherwise
        pinned, as by
      <a class="link" href="../htmlman2/sched_setaffinity.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         sched_setaffinity
        </span>
        (2)
       </span>
      </a>
      )
        from any CPU in that cpuset to any other.
     </p>
     <p>
      When the per-cpuset flag
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      is
        disabled, then the scheduler will avoid load balancing
        across the CPUs in that cpuset,
      <em class="replaceable">
       <code>
        except
       </code>
      </em>
      in so far as is
        necessary because some overlapping cpuset has
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      enabled.
     </p>
     <p>
      So, for example, if the top cpuset has the flag
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      enabled,
        then the scheduler will load balance across all CPUs, and
        the setting of the
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      flag in
        other cpusets has no effect, as we're already fully load
        balancing.
     </p>
     <p>
      Therefore in the above two situations, the flag
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      should
        be disabled in the top cpuset, and only some of the
        smaller, child cpusets would have this flag enabled.
     </p>
     <p>
      When doing this, you don't usually want to leave any
        unpinned processes in the top cpuset that might use
        nontrivial amounts of CPU, as such processes may be
        artificially constrained to some subset of CPUs, depending
        on the particulars of this flag setting in descendant
        cpusets. Even if such a process could use spare CPU cycles
        in some other CPUs, the kernel scheduler might not consider
        the possibility of load balancing that process to the
        underused CPU.
     </p>
     <p>
      Of course, processes pinned to a particular CPU can be
        left in a cpuset that disables
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      as those
        processes aren't going anywhere else anyway.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect11" name="cpuset-7_sect11" shape="rect">
     </a>
     <h3>
      Scheduler relax domain level
     </h3>
     <p>
      The kernel scheduler performs immediate load balancing
        whenever a CPU becomes free or another task becomes
        runnable. This load balancing works to ensure that as many
        CPUs as possible are usefully employed running tasks. The
        kernel also performs periodic load balancing off the
        software clock described in
      <a class="link" href="../htmlman7/time.7.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         time
        </span>
        (7)
       </span>
      </a>
      . The setting of
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      applies only to immediate load balancing. Regardless of the
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      setting, periodic load balancing is attempted over all CPUs
        (unless disabled by turning off
      <em class="replaceable">
       <code>
        sched_load_balance
       </code>
      </em>
      .) In any
        case, of course, tasks will be scheduled to run only on
        CPUs allowed by their cpuset, as modified by
      <a class="link" href="../htmlman2/sched_setaffinity.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         sched_setaffinity
        </span>
        (2)
       </span>
      </a>
      system calls.
     </p>
     <p>
      On small systems, such as those with just a few CPUs,
        immediate load balancing is useful to improve system
        interactivity and to minimize wasteful idle CPU cycles. But
        on large systems, attempting immediate load balancing
        across a large number of CPUs can be more costly than it is
        worth, depending on the particular performance
        characteristics of the job mix and the hardware.
     </p>
     <p>
      The exact meaning of the small integer values of
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      will depend on internal implementation details of the
        kernel scheduler code and on the non-uniform architecture
        of the hardware. Both of these will evolve over time and
        vary by system architecture and kernel version.
     </p>
     <p>
      As of this writing, when this capability was introduced
        in Linux 2.6.26, on certain popular architectures, the
        positive values of
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      have the following meanings.
     </p>
     <div class="variablelist">
      <dl class="variablelist">
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           (1)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Perform immediate load balancing across
              Hyper-Thread siblings on the same core.
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           (2)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Perform immediate load balancing across other
              cores in the same package.
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           (3)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Perform immediate load balancing across other CPUs
              on the same node or blade.
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           (4)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Perform immediate load balancing across over
              several (implementation detail) nodes [On NUMA
              systems].
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           (5)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Perform immediate load balancing across over all
              CPUs in system [On NUMA systems].
        </p>
       </dd>
      </dl>
     </div>
     <p>
      The
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      value of zero (0) always means don't perform immediate load
        balancing, hence that load balancing is done only
        periodically, not immediately when a CPU becomes available
        or another task becomes runnable.
     </p>
     <p>
      The
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      value of minus one (&minus;1) always means use the system
        default value. The system default value can vary by
        architecture and kernel version. This system default value
        can be changed by kernel boot-time "relax_domain_level="
        argument.
     </p>
     <p>
      In the case of multiple overlapping cpusets which have
        conflicting
      <em class="replaceable">
       <code>
        sched_relax_domain_level
       </code>
      </em>
      values, then the highest such value applies to all CPUs in
        any of the overlapping cpusets. In such cases, the value
      <span class="emphasis">
       <em>
        minus one (&minus;1)
       </em>
      </span>
      is the lowest value, overridden by any other value, and the
        value
      <span class="emphasis">
       <em>
        zero (0)
       </em>
      </span>
      is
        the next lowest value.
     </p>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect12" name="cpuset-7_sect12" shape="rect">
    </a>
    <h2>
     FORMATS
    </h2>
    <p>
     The following formats are used to represent sets of CPUs
      and memory nodes.
    </p>
    <div class="refsect2">
     <a id="cpuset-7_sect13" name="cpuset-7_sect13" shape="rect">
     </a>
     <h3>
      Mask format
     </h3>
     <p>
      The
      <span class="emphasis">
       <em>
        Mask Format
       </em>
      </span>
      is used to represent CPU and memory-node bit masks in the
      <code class="filename">
       /proc/&lt;pid&gt;/status
      </code>
      file.
     </p>
     <p>
      This format displays each 32-bit word in hexadecimal
        (using ASCII characters "0" - "9" and "a" - "f"); words are
        filled with leading zeros, if required. For masks longer
        than one word, a comma separator is used between words.
        Words are displayed in big-endian order, which has the most
        significant bit first. The hex digits within a word are
        also in big-endian order.
     </p>
     <p>
      The number of 32-bit words displayed is the minimum
        number needed to display all bits of the bit mask, based on
        the size of the bit mask.
     </p>
     <p>
      Examples of the
      <span class="emphasis">
       <em>
        Mask
        Format
       </em>
      </span>
      :
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
00000001                        # just bit 0 set
40000000,00000000,00000000      # just bit 94 set
00000001,00000000,00000000      # just bit 64 set
000000ff,00000000               # bits 32-39 set
00000000,000e3862               # 1,5,6,11-13,17-19 set
</pre>
       </div>
      </blockquote>
     </div>
     <p>
      A mask with bits 0, 1, 2, 4, 8, 16, 32, and 64 set
        displays as:
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
00000001,00000001,00010117
</pre>
       </div>
      </blockquote>
     </div>
     <p>
      The first "1" is for bit 64, the second for bit 32, the
        third for bit 16, the fourth for bit 8, the fifth for bit
        4, and the "7" is for bits 2, 1, and 0.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect14" name="cpuset-7_sect14" shape="rect">
     </a>
     <h3>
      List format
     </h3>
     <p>
      The
      <span class="emphasis">
       <em>
        List Format
       </em>
      </span>
      for
      <em class="replaceable">
       <code>
        cpus
       </code>
      </em>
      and
      <em class="replaceable">
       <code>
        mems
       </code>
      </em>
      is a
        comma-separated list of CPU or memory-node numbers and
        ranges of numbers, in ASCII decimal.
     </p>
     <p>
      Examples of the
      <span class="emphasis">
       <em>
        List
        Format
       </em>
      </span>
      :
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
0-4,9           # bits 0, 1, 2, 3, 4, and 9 set
0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13, and 14 set
</pre>
       </div>
      </blockquote>
     </div>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect15" name="cpuset-7_sect15" shape="rect">
    </a>
    <h2>
     RULES
    </h2>
    <p>
     The following rules apply to each cpuset:
    </p>
    <div class="itemizedlist">
     <ul class="itemizedlist" style="list-style-type: disc;">
      <li class="listitem">
       <p>
        Its CPUs and memory nodes must be a (possibly equal)
            subset of its parent's.
       </p>
      </li>
      <li class="listitem">
       <p>
        It can be marked
        <em class="replaceable">
         <code>
          cpu_exclusive
         </code>
        </em>
        only if
            its parent is.
       </p>
      </li>
      <li class="listitem">
       <p>
        It can be marked
        <em class="replaceable">
         <code>
          mem_exclusive
         </code>
        </em>
        only if
            its parent is.
       </p>
      </li>
      <li class="listitem">
       <p>
        If it is
        <em class="replaceable">
         <code>
          cpu_exclusive
         </code>
        </em>
        , its CPUs
            may not overlap any sibling.
       </p>
      </li>
      <li class="listitem">
       <p>
        If it is
        <em class="replaceable">
         <code>
          memory_exclusive
         </code>
        </em>
        , its
            memory nodes may not overlap any sibling.
       </p>
      </li>
     </ul>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect16" name="cpuset-7_sect16" shape="rect">
    </a>
    <h2>
     PERMISSIONS
    </h2>
    <p>
     The permissions of a cpuset are determined by the
      permissions of the directories and pseudo-files in the cpuset
      filesystem, normally mounted at
     <code class="filename">
      /dev/cpuset
     </code>
     .
    </p>
    <p>
     For instance, a process can put itself in some other
      cpuset (than its current one) if it can write the
     <em class="replaceable">
      <code>
       tasks
      </code>
     </em>
     file for that cpuset.
      This requires execute permission on the encompassing
      directories and write permission on the
     <em class="replaceable">
      <code>
       tasks
      </code>
     </em>
     file.
    </p>
    <p>
     An additional constraint is applied to requests to place
      some other process in a cpuset. One process may not attach
      another to a cpuset unless it would have permission to send
      that process a signal (see
     <a class="link" href="../htmlman2/kill.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        kill
       </span>
       (2)
      </span>
     </a>
     ).
    </p>
    <p>
     A process may create a child cpuset if it can access and
      write the parent cpuset directory. It can modify the CPUs or
      memory nodes in a cpuset if it can access that cpuset's
      directory (execute permissions on the each of the parent
      directories) and write the corresponding
     <em class="replaceable">
      <code>
       cpus
      </code>
     </em>
     or
     <em class="replaceable">
      <code>
       mems
      </code>
     </em>
     file.
    </p>
    <p>
     There is one minor difference between the manner in which
      these permissions are evaluated and the manner in which
      normal filesystem operation permissions are evaluated. The
      kernel interprets relative pathnames starting at a process's
      current working directory. Even if one is operating on a
      cpuset file, relative pathnames are interpreted relative to
      the process's current working directory, not relative to the
      process's current cpuset. The only ways that cpuset paths
      relative to a process's current cpuset can be used are if
      either the process's current working directory is its cpuset
      (it first did a
     <em class="replaceable">
      <code>
       cd
      </code>
     </em>
     or
     <a class="link" href="../htmlman2/chdir.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        chdir
       </span>
       (2)
      </span>
     </a>
     to its cpuset
      directory beneath
     <code class="filename">
      /dev/cpuset
     </code>
     ,
      which is a bit unusual) or if some user code converts the
      relative cpuset path to a full filesystem path.
    </p>
    <p>
     In theory, this means that user code should specify
      cpusets using absolute pathnames, which requires knowing the
      mount point of the cpuset filesystem (usually, but not
      necessarily,
     <code class="filename">
      /dev/cpuset
     </code>
     ). In
      practice, all user level code that this author is aware of
      simply assumes that if the cpuset filesystem is mounted, then
      it is mounted at
     <code class="filename">
      /dev/cpuset
     </code>
     .
      Furthermore, it is common practice for carefully written user
      code to verify the presence of the pseudo-file
     <code class="filename">
      /dev/cpuset/tasks
     </code>
     in order to verify that
      the cpuset pseudo-filesystem is currently mounted.
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect17" name="cpuset-7_sect17" shape="rect">
    </a>
    <h2>
     WARNINGS
    </h2>
    <div class="refsect2">
     <a id="cpuset-7_sect18" name="cpuset-7_sect18" shape="rect">
     </a>
     <h3>
      Enabling memory_pressure
     </h3>
     <p>
      By default, the per-cpuset file
      <em class="replaceable">
       <code>
        cpuset.memory_pressure
       </code>
      </em>
      always contains zero (0). Unless this feature is enabled by
        writing "1" to the pseudo-file
      <code class="filename">
       /dev/cpuset/cpuset.memory_pressure_enabled
      </code>
      ,
        the kernel does not compute per-cpuset
      <em class="replaceable">
       <code>
        memory_pressure
       </code>
      </em>
      .
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect19" name="cpuset-7_sect19" shape="rect">
     </a>
     <h3>
      Using the echo command
     </h3>
     <p>
      When using the
      <em class="replaceable">
       <code>
        echo
       </code>
      </em>
      command at the shell
        prompt to change the values of cpuset files, beware that
        the built-in
      <em class="replaceable">
       <code>
        echo
       </code>
      </em>
      command in some shells does not display an error message if
        the
      <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         write
        </span>
        (2)
       </span>
      </a>
      system call
        fails. For example, if the command:
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
echo 19 &gt; cpuset.mems
</pre>
       </div>
      </blockquote>
     </div>
     <p>
      failed because memory node 19 was not allowed (perhaps
        the current system does not have a memory node 19), then
        the
      <em class="replaceable">
       <code>
        echo
       </code>
      </em>
      command
        might not display any error. It is better to use the
      <code class="filename">
       /bin/echo
      </code>
      external command to
        change cpuset file settings, as this command will display
      <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         write
        </span>
        (2)
       </span>
      </a>
      errors, as in
        the example:
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
/bin/echo 19 &gt; cpuset.mems
/bin/echo: write error: Invalid argument
</pre>
       </div>
      </blockquote>
     </div>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect20" name="cpuset-7_sect20" shape="rect">
    </a>
    <h2>
     EXCEPTIONS
    </h2>
    <div class="refsect2">
     <a id="cpuset-7_sect21" name="cpuset-7_sect21" shape="rect">
     </a>
     <h3>
      Memory placement
     </h3>
     <p>
      Not all allocations of system memory are constrained by
        cpusets, for the following reasons.
     </p>
     <p>
      If hot-plug functionality is used to remove all the CPUs
        that are currently assigned to a cpuset, then the kernel
        will automatically update the
      <em class="replaceable">
       <code>
        cpus_allowed
       </code>
      </em>
      of all
        processes attached to CPUs in that cpuset to allow all
        CPUs. When memory hot-plug functionality for removing
        memory nodes is available, a similar exception is expected
        to apply there as well. In general, the kernel prefers to
        violate cpuset placement, rather than starving a process
        that has had all its allowed CPUs or memory nodes taken
        offline. User code should reconfigure cpusets to refer only
        to online CPUs and memory nodes when using hot-plug to add
        or remove such resources.
     </p>
     <p>
      A few kernel-critical, internal memory-allocation
        requests, marked GFP_ATOMIC, must be satisfied immediately.
        The kernel may drop some request or malfunction if one of
        these allocations fail. If such a request cannot be
        satisfied within the current process's cpuset, then we
        relax the cpuset, and look for memory anywhere we can find
        it. It's better to violate the cpuset than stress the
        kernel.
     </p>
     <p>
      Allocations of memory requested by kernel drivers while
        processing an interrupt lack any relevant process context,
        and are not confined by cpusets.
     </p>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect22" name="cpuset-7_sect22" shape="rect">
     </a>
     <h3>
      Renaming cpusets
     </h3>
     <p>
      You can use the
      <a class="link" href="../htmlman2/rename.2.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         rename
        </span>
        (2)
       </span>
      </a>
      system call to
        rename cpusets. Only simple renaming is supported; that is,
        changing the name of a cpuset directory is permitted, but
        moving a directory into a different directory is not
        permitted.
     </p>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect23" name="cpuset-7_sect23" shape="rect">
    </a>
    <h2>
     ERRORS
    </h2>
    <p>
     The Linux kernel implementation of cpusets sets
     <code class="varname">
      errno
     </code>
     to specify the reason for
      a failed system call affecting cpusets.
    </p>
    <p>
     The possible
     <code class="varname">
      errno
     </code>
     settings
      and their meaning when set on a failed cpuset call are as
      listed below.
    </p>
    <div class="variablelist">
     <dl class="variablelist">
      <dt>
       <span class="term">
        <span class="errorname">
         E2BIG
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted a
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        on a special
            cpuset file with a length larger than some
            kernel-determined upper limit on the length of such
            writes.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EACCES
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        the process
            ID (PID) of a process to a cpuset
        <em class="replaceable">
         <code>
          tasks
         </code>
        </em>
        file when one
            lacks permission to move that process.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EACCES
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to add, using
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        , a CPU or
            memory node to a cpuset, when that CPU or memory node
            was not already in its parent.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EACCES
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to set, using
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        ,
        <em class="replaceable">
         <code>
          cpuset.cpu_exclusive
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          cpuset.mem_exclusive
         </code>
        </em>
        on
            a cpuset whose parent lacks the same setting.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EACCES
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a
        <em class="replaceable">
         <code>
          cpuset.memory_pressure
         </code>
        </em>
        file.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EACCES
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to create a file in a cpuset
            directory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EBUSY
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to remove, using
        <a class="link" href="../htmlman2/rmdir.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           rmdir
          </span>
          (2)
         </span>
        </a>
        , a cpuset
            with attached processes.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EBUSY
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to remove, using
        <a class="link" href="../htmlman2/rmdir.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           rmdir
          </span>
          (2)
         </span>
        </a>
        , a cpuset
            with child cpusets.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EBUSY
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to remove a CPU or memory node from a
            cpuset that is also in a child of that cpuset.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EEXIST
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to create, using
        <a class="link" href="../htmlman2/mkdir.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mkdir
          </span>
          (2)
         </span>
        </a>
        , a cpuset
            that already exists.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EEXIST
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/rename.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           rename
          </span>
          (2)
         </span>
        </a>
        a cpuset to
            a name that already exists.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EFAULT
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/read.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           read
          </span>
          (2)
         </span>
        </a>
        or
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a cpuset
            file using a buffer that is outside the writing
            processes accessible address space.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to change a cpuset, using
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        , in a way
            that would violate a
        <em class="replaceable">
         <code>
          cpu_exclusive
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          mem_exclusive
         </code>
        </em>
        attribute of that cpuset or any of its siblings.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        an empty
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        list to a
            cpuset which has attached processes or child
            cpusets.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        list which included a range with the second number
            smaller than the first number.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        list which included an invalid character in the
            string.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a list to a
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        file that did not include any online CPUs.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a list to a
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        file that did not include any online memory nodes.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a list to a
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        file that included a node that held no memory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EIO
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        a string to
            a cpuset
        <em class="replaceable">
         <code>
          tasks
         </code>
        </em>
        file that does
            not begin with an ASCII decimal integer.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EIO
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/rename.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           rename
          </span>
          (2)
         </span>
        </a>
        a cpuset
            into a different directory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENAMETOOLONG
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/read.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           read
          </span>
          (2)
         </span>
        </a>
        a
        <code class="filename">
         /proc/&lt;pid&gt;/cpuset
        </code>
        file for a cpuset path that is longer than the kernel
            page size.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENAMETOOLONG
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to create, using
        <a class="link" href="../htmlman2/mkdir.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mkdir
          </span>
          (2)
         </span>
        </a>
        , a cpuset
            whose base directory name is longer than 255
            characters.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENAMETOOLONG
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to create, using
        <a class="link" href="../htmlman2/mkdir.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mkdir
          </span>
          (2)
         </span>
        </a>
        , a cpuset
            whose full pathname, including the mount point
            (typically "/dev/cpuset/") prefix, is longer than 4095
            characters.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENODEV
        </span>
       </span>
      </dt>
      <dd>
       <p>
        The cpuset was removed by another process at the
            same time as a
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        was
            attempted on one of the pseudo-files in the cpuset
            directory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENOENT
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to create, using
        <a class="link" href="../htmlman2/mkdir.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mkdir
          </span>
          (2)
         </span>
        </a>
        , a cpuset in
            a parent cpuset that doesn't exist.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENOENT
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/access.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           access
          </span>
          (2)
         </span>
        </a>
        or
        <a class="link" href="../htmlman2/open.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           open
          </span>
          (2)
         </span>
        </a>
        a nonexistent
            file in a cpuset directory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENOMEM
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Insufficient memory is available within the kernel;
            can occur on a variety of system calls affecting
            cpusets, but only if the system is extremely short of
            memory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENOSPC
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        the process
            ID (PID) of a process to a cpuset
        <em class="replaceable">
         <code>
          tasks
         </code>
        </em>
        file when the
            cpuset had an empty
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        or empty
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        setting.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENOSPC
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        an empty
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        setting to
            a cpuset that has tasks attached.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ENOTDIR
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/rename.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           rename
          </span>
          (2)
         </span>
        </a>
        a
            nonexistent cpuset.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EPERM
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to remove a file from a cpuset
            directory.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ERANGE
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Specified a
        <em class="replaceable">
         <code>
          cpuset.cpus
         </code>
        </em>
        or
        <em class="replaceable">
         <code>
          cpuset.mems
         </code>
        </em>
        list to the kernel which included a number too large
            for the kernel to set in its bit masks.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ESRCH
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Attempted to
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        the process
            ID (PID) of a nonexistent process to a cpuset
        <em class="replaceable">
         <code>
          tasks
         </code>
        </em>
        file.
       </p>
      </dd>
     </dl>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect24" name="cpuset-7_sect24" shape="rect">
    </a>
    <h2>
     VERSIONS
    </h2>
    <p>
     Cpusets appeared in version 2.6.12 of the Linux
      kernel.
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect25" name="cpuset-7_sect25" shape="rect">
    </a>
    <h2>
     NOTES
    </h2>
    <p>
     Despite its name, the
     <em class="replaceable">
      <code>
       pid
      </code>
     </em>
     parameter is actually a
      thread ID, and each thread in a threaded group can be
      attached to a different cpuset. The value returned from a
      call to
     <a class="link" href="../htmlman2/gettid.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        gettid
       </span>
       (2)
      </span>
     </a>
     can be passed in
      the argument
     <em class="replaceable">
      <code>
       pid
      </code>
     </em>
     .
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect26" name="cpuset-7_sect26" shape="rect">
    </a>
    <h2>
     BUGS
    </h2>
    <p>
     <em class="replaceable">
      <code>
       cpuset.memory_pressure
      </code>
     </em>
     cpuset
      files can be opened for writing, creation, or truncation, but
      then the
     <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        write
       </span>
       (2)
      </span>
     </a>
     fails with
     <code class="varname">
      errno
     </code>
     set to
     <span class="errorname">
      EACCES
     </span>
     , and the creation and truncation
      options on
     <a class="link" href="../htmlman2/open.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        open
       </span>
       (2)
      </span>
     </a>
     have no effect.
    </p>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect27" name="cpuset-7_sect27" shape="rect">
    </a>
    <h2>
     EXAMPLE
    </h2>
    <p>
     The following examples demonstrate querying and setting
      cpuset options using shell commands.
    </p>
    <div class="refsect2">
     <a id="cpuset-7_sect28" name="cpuset-7_sect28" shape="rect">
     </a>
     <h3>
      Creating and attaching to a cpuset.
     </h3>
     <p>
      To create a new cpuset and attach the current command
        shell to it, the steps are:
     </p>
     <div class="variablelist">
      <dl class="variablelist">
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           1)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         mkdir /dev/cpuset (if not already done)
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           2)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         mount &minus;t cpuset none /dev/cpuset (if not
              already done)
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           3)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Create the new cpuset using
         <a class="link" href="../htmlman1/mkdir.1.html" shape="rect" target="_top">
          <span class="citerefentry">
           <span class="refentrytitle">
            mkdir
           </span>
           (1)
          </span>
         </a>
         .
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           4)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Assign CPUs and memory nodes to the new
              cpuset.
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           5)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Attach the shell to the new cpuset.
        </p>
       </dd>
      </dl>
     </div>
     <p>
      For example, the following sequence of commands will set
        up a cpuset named "Charlie", containing just CPUs 2 and 3,
        and memory node 1, and then attach the current shell to
        that cpuset.
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
$<span class="emphasis"><em> mkdir /dev/cpuset</em></span>
$<span class="emphasis"><em> mount &minus;t cpuset cpuset /dev/cpuset</em></span>
$<span class="emphasis"><em> cd /dev/cpuset</em></span>
$<span class="emphasis"><em> mkdir Charlie</em></span>
$<span class="emphasis"><em> cd Charlie</em></span>
$<span class="emphasis"><em> /bin/echo 2-3 &gt; cpuset.cpus</em></span>
$<span class="emphasis"><em> /bin/echo 1 &gt; cpuset.mems</em></span>
$<span class="emphasis"><em> /bin/echo $$ &gt; tasks</em></span>
# The current shell is now running in cpuset Charlie
# The next line should display '/Charlie'
$<span class="emphasis"><em> cat /proc/self/cpuset</em></span>
</pre>
       </div>
      </blockquote>
     </div>
    </div>
    <div class="refsect2">
     <a id="cpuset-7_sect29" name="cpuset-7_sect29" shape="rect">
     </a>
     <h3>
      Migrating a job to different memory nodes.
     </h3>
     <p>
      To migrate a job (the set of processes attached to a
        cpuset) to different CPUs and memory nodes in the system,
        including moving the memory pages currently allocated to
        that job, perform the following steps.
     </p>
     <div class="variablelist">
      <dl class="variablelist">
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           1)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Let's say we want to move the job in cpuset
         <em class="replaceable">
          <code>
           alpha
          </code>
         </em>
         (CPUs
              4-7 and memory nodes 2-3) to a new cpuset
         <em class="replaceable">
          <code>
           beta
          </code>
         </em>
         (CPUs 16-19 and
              memory nodes 8-9).
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           2)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         First create the new cpuset
         <em class="replaceable">
          <code>
           beta
          </code>
         </em>
         .
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           3)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Then allow CPUs 16-19 and memory nodes 8-9 in
         <em class="replaceable">
          <code>
           beta
          </code>
         </em>
         .
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           4)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Then enable
         <em class="replaceable">
          <code>
           memory_migration
          </code>
         </em>
         in
         <em class="replaceable">
          <code>
           beta
          </code>
         </em>
         .
        </p>
       </dd>
       <dt>
        <span class="term">
         <em class="replaceable">
          <code>
           5)
          </code>
         </em>
        </span>
       </dt>
       <dd>
        <p>
         Then move each process from
         <em class="replaceable">
          <code>
           alpha
          </code>
         </em>
         to
         <em class="replaceable">
          <code>
           beta
          </code>
         </em>
         .
        </p>
       </dd>
      </dl>
     </div>
     <p>
      The following sequence of commands accomplishes
        this.
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
$<span class="emphasis"><em> cd /dev/cpuset</em></span>
$<span class="emphasis"><em> mkdir beta</em></span>
$<span class="emphasis"><em> cd beta</em></span>
$<span class="emphasis"><em> /bin/echo 16-19 &gt; cpuset.cpus</em></span>
$<span class="emphasis"><em> /bin/echo 8-9 &gt; cpuset.mems</em></span>
$<span class="emphasis"><em> /bin/echo 1 &gt; cpuset.memory_migrate</em></span>
$<span class="emphasis"><em> while read i; do /bin/echo $i; done &lt; ../alpha/tasks &gt; tasks</em></span>
</pre>
       </div>
      </blockquote>
     </div>
     <p>
      The above should move any processes in
      <em class="replaceable">
       <code>
        alpha
       </code>
      </em>
      to
      <em class="replaceable">
       <code>
        beta
       </code>
      </em>
      , and any memory held
        by these processes on memory nodes 2-3 to memory nodes 8-9,
        respectively.
     </p>
     <p>
      Notice that the last step of the above sequence did not
        do:
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
$<span class="emphasis"><em> cp ../alpha/tasks tasks</em></span>
</pre>
       </div>
      </blockquote>
     </div>
     <p>
      The
      <em class="replaceable">
       <code>
        while
       </code>
      </em>
      loop, rather than the seemingly easier use of the
      <a class="link" href="../htmlman1/cp.1.html" shape="rect" target="_top">
       <span class="citerefentry">
        <span class="refentrytitle">
         cp
        </span>
        (1)
       </span>
      </a>
      command, was
        necessary because only one process PID at a time may be
        written to the
      <em class="replaceable">
       <code>
        tasks
       </code>
      </em>
      file.
     </p>
     <p>
      The same effect (writing one PID at a time) as the
      <em class="replaceable">
       <code>
        while
       </code>
      </em>
      loop can be
        accomplished more efficiently, in fewer keystrokes and in
        syntax that works on any shell, but alas more obscurely, by
        using the
      <code class="option">
       &minus;u
      </code>
      (unbuffered)
        option of
      <span class="citerefentry">
       <span class="refentrytitle">
        sed
       </span>
       (1)
      </span>
      :
     </p>
     <div class="blockquote">
      <blockquote class="blockquote">
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
$<span class="emphasis"><em> sed &minus;un p &lt; ../alpha/tasks &gt; tasks</em></span>
</pre>
       </div>
      </blockquote>
     </div>
    </div>
   </div>
   <div class="refsect1">
    <a id="cpuset-7_sect30" name="cpuset-7_sect30" shape="rect">
    </a>
    <h2>
     SEE ALSO
    </h2>
    <p>
     <a class="link" href="../htmlman1/taskset.1.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        taskset
       </span>
       (1)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/get_mempolicy.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        get_mempolicy
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/getcpu.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        getcpu
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/mbind.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mbind
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/sched_setaffinity.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sched_getaffinity
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/sched_setaffinity.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sched_setaffinity
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/sched_setscheduler.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sched_setscheduler
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/set_mempolicy.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        set_mempolicy
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/CPU_SET.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        CPU_SET
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman5/proc.5.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        proc
       </span>
       (5)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman7/numa.7.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        numa
       </span>
       (7)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman7/sched.7.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sched
       </span>
       (7)
      </span>
     </a>
     ,
     <span class="citerefentry">
      <span class="refentrytitle">
       migratepages
      </span>
      (8)
     </span>
     ,
     <span class="citerefentry">
      <span class="refentrytitle">
       numactl
      </span>
      (8)
     </span>
    </p>
    <p>
     <code class="filename">
      Documentation/cpusets.txt
     </code>
     in
      the Linux kernel source tree
    </p>
   </div>
   <div class="colophon">
    <a id="cpuset-7_sect31" name="cpuset-7_sect31" shape="rect">
    </a>
    <h2>
     COLOPHON
    </h2>
    <p>
     This page is part of release 3.72 of the Linux
     <em class="replaceable">
      <code>
       man-pages
      </code>
     </em>
     project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      http://www.kernel.org/doc/man&minus;pages/.
    </p>
   </div>
  </div>
 </body>
</html>
