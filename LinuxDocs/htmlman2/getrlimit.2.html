<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <title>
   getrlimit(2) &mdash; Linux manual pages
  </title>
  <link href="../stylesheet/manpages.css" rel="stylesheet" type="text/css"/>
  <link href="../index.html" rel="home" title="getrlimit(2) &mdash; Linux manual pages"/>
  <script src="../stylesheet/manpages.js" type="text/javascript" xml:space="preserve">
  </script>
  <link href="../stylesheet/icon.gif" rel="icon" type="image/gif"/>
 </head>
 <body>
  <div class="refentry">
   <a id="getrlimit.2" name="getrlimit.2" shape="rect">
   </a>
   <div class="titlepage">
   </div>
   <div class="refnamediv">
    <h2>
     Name
    </h2>
    <p>
     getrlimit, setrlimit, prlimit &mdash; get/set resource
      limits
    </p>
   </div>
   <div class="refsynopsisdiv">
    <h2>
     Synopsis
    </h2>
    <div class="informalexample">
     <pre class="programlisting" xml:space="preserve">
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
</pre>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         int
         <strong>
          getrlimit
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        int
        <var class="pdparam">
         resource
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        struct rlimit *
        <var class="pdparam">
         rlim
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         int
         <strong>
          setrlimit
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        int
        <var class="pdparam">
         resource
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        const struct rlimit *
        <var class="pdparam">
         rlim
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         int
         <strong>
          prlimit
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        pid_t
        <var class="pdparam">
         pid
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        int
        <var class="pdparam">
         resource
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        const struct rlimit *
        <var class="pdparam">
         new_limit
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        struct rlimit *
        <var class="pdparam">
         old_limit
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tr>
       <td align="center" colspan="1" rowspan="2" valign="top" width="25">
        <img alt="[Note]" src="../stylesheet/note.png"/>
       </td>
       <th align="left" colspan="1" rowspan="1">
        Note
       </th>
      </tr>
      <tr>
       <td align="left" colspan="1" rowspan="1" valign="top">
        <div class="featuretests">
         <table style="border-collapse: collapse;">
          <colgroup span="1">
           <col span="1">
           </col>
          </colgroup>
          <thead>
           <tr>
            <th colspan="1" rowspan="1" style="">
             Feature Test Macro Requirements
                      for glibc (see
             <a class="link" href="../htmlman7/feature_test_macros.7.html" shape="rect" target="_top">
              <span class="citerefentry">
               <span class="refentrytitle">
                feature_test_macros
               </span>
               (7)
              </span>
             </a>
             ):
            </th>
           </tr>
          </thead>
          <tbody>
           <tr>
            <td colspan="1" rowspan="1" style="">
             <code class="function">
              prlimit
             </code>
             ():
            </td>
           </tr>
           <tr>
            <td class="featuretestdef" colspan="1" rowspan="1" style="">
             <code class="constant">
              _GNU_SOURCE
             </code>
             &amp;&amp; _FILE_OFFSET_BITS == 64
            </td>
           </tr>
          </tbody>
         </table>
        </div>
       </td>
      </tr>
     </table>
    </div>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect1" name="getrlimit-2_sect1" shape="rect">
    </a>
    <h2>
     DESCRIPTION
    </h2>
    <p>
     The
     <code class="function">
      getrlimit
     </code>
     () and
     <code class="function">
      setrlimit
     </code>
     () system calls get
      and set resource limits respectively. Each resource has an
      associated soft and hard limit, as defined by the
     <span class="structname">
      rlimit
     </span>
     structure:
    </p>
    <div class="blockquote">
     <blockquote class="blockquote">
      <div class="structdef">
       <table style="border-collapse: collapse;">
        <colgroup span="1">
         <col class="c1" span="1">
         </col>
         <col class="c2" span="1">
         </col>
         <col class="c3" span="1">
         </col>
         <col class="c4" span="1">
         </col>
         <col class="c5" span="1">
         </col>
        </colgroup>
        <tbody>
         <tr>
          <td align="left" class="structdefhdr" colspan="1" rowspan="1" style="">
           struct
          </td>
          <td align="left" class="structdefhdr" colspan="4" rowspan="1" style="">
           <span class="structname">
            rlimit
           </span>
           &nbsp;{
          </td>
         </tr>
         <tr>
          <td colspan="1" rowspan="1" style="">
           &nbsp;
          </td>
          <td align="left" colspan="1" rowspan="1" style="">
           <span class="type">
            rlim_t
           </span>
          </td>
          <td align="right" class="norightpad" colspan="1" rowspan="1" style="">
           &nbsp;
          </td>
          <td align="left" colspan="1" rowspan="1" style="">
           <em class="structfield">
            <code>
             rlim_cur
            </code>
           </em>
           ;
          </td>
          <td align="left" colspan="1" rowspan="1" style="">
           <div class="literallayout">
            /*&nbsp;Soft&nbsp;limit&nbsp;*/
           </div>
          </td>
         </tr>
         <tr>
          <td colspan="1" rowspan="1" style="">
           &nbsp;
          </td>
          <td align="left" colspan="1" rowspan="1" style="">
           <span class="type">
            rlim_t
           </span>
          </td>
          <td align="right" class="norightpad" colspan="1" rowspan="1" style="">
           &nbsp;
          </td>
          <td align="left" colspan="1" rowspan="1" style="">
           <em class="structfield">
            <code>
             rlim_max
            </code>
           </em>
           ;
          </td>
          <td align="left" colspan="1" rowspan="1" style="">
           <div class="literallayout">
            /*&nbsp;Hard&nbsp;limit&nbsp;(ceiling&nbsp;for&nbsp;rlim_cur)&nbsp;*/
           </div>
          </td>
         </tr>
         <tr>
          <td align="left" class="structdefftr" colspan="5" rowspan="1" style="">
           };
          </td>
         </tr>
        </tbody>
       </table>
      </div>
     </blockquote>
    </div>
    <p>
     The soft limit is the value that the kernel enforces for
      the corresponding resource. The hard limit acts as a ceiling
      for the soft limit: an unprivileged process may set only its
      soft limit to a value in the range from 0 up to the hard
      limit, and (irreversibly) lower its hard limit. A privileged
      process (under Linux: one with the
     <code class="constant">
      CAP_SYS_RESOURCE
     </code>
     capability) may make
      arbitrary changes to either limit value.
    </p>
    <p>
     The value
     <code class="constant">
      RLIM_INFINITY
     </code>
     denotes no limit on a resource (both in the structure
      returned by
     <code class="function">
      getrlimit
     </code>
     () and in
      the structure passed to
     <code class="function">
      setrlimit
     </code>
     ()).
    </p>
    <p>
     The
     <em class="parameter">
      <code>
       resource
      </code>
     </em>
     argument must be one of:
    </p>
    <div class="variablelist">
     <dl class="variablelist">
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_AS
        </code>
       </span>
      </dt>
      <dd>
       <p>
        The maximum size of the process's virtual memory
            (address space) in bytes. This limit affects calls to
        <a class="link" href="../htmlman2/brk.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           brk
          </span>
          (2)
         </span>
        </a>
        ,
        <a class="link" href="../htmlman2/mmap.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mmap
          </span>
          (2)
         </span>
        </a>
        , and
        <a class="link" href="../htmlman2/mremap.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mremap
          </span>
          (2)
         </span>
        </a>
        , which fail
            with the error
        <span class="errorname">
         ENOMEM
        </span>
        upon exceeding this limit. Also automatic stack
            expansion will fail (and generate a
        <code class="constant">
         SIGSEGV
        </code>
        that kills the process if no
            alternate stack has been made available via
        <a class="link" href="../htmlman2/sigaltstack.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sigaltstack
          </span>
          (2)
         </span>
        </a>
        ).
            Since the value is a
        <span class="type">
         long
        </span>
        , on
            machines with a 32-bit
        <span class="type">
         long
        </span>
        either this limit is at most 2 GiB, or this resource is
            unlimited.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_CORE
        </code>
       </span>
      </dt>
      <dd>
       <p>
        Maximum size of a
        <em class="replaceable">
         <code>
          core
         </code>
        </em>
        file (see
        <a class="link" href="../htmlman5/core.5.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           core
          </span>
          (5)
         </span>
        </a>
        ). When 0 no
            core dump files are created. When nonzero, larger dumps
            are truncated to this size.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_CPU
        </code>
       </span>
      </dt>
      <dd>
       <p>
        CPU time limit in seconds. When the process reaches
            the soft limit, it is sent a
        <code class="constant">
         SIGXCPU
        </code>
        signal. The default action
            for this signal is to terminate the process. However,
            the signal can be caught, and the handler can return
            control to the main program. If the process continues
            to consume CPU time, it will be sent
        <code class="constant">
         SIGXCPU
        </code>
        once per second until the
            hard limit is reached, at which time it is sent
        <code class="constant">
         SIGKILL
        </code>
        . (This latter
            point describes Linux behavior. Implementations vary in
            how they treat processes which continue to consume CPU
            time after reaching the soft limit. Portable
            applications that need to catch this signal should
            perform an orderly termination upon first receipt of
        <code class="constant">
         SIGXCPU
        </code>
        .)
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_DATA
        </code>
       </span>
      </dt>
      <dd>
       <p>
        The maximum size of the process's data segment
            (initialized data, uninitialized data, and heap). This
            limit affects calls to
        <a class="link" href="../htmlman2/brk.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           brk
          </span>
          (2)
         </span>
        </a>
        and
        <a class="link" href="../htmlman2/brk.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sbrk
          </span>
          (2)
         </span>
        </a>
        , which fail
            with the error
        <span class="errorname">
         ENOMEM
        </span>
        upon encountering the soft limit of this resource.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_FSIZE
        </code>
       </span>
      </dt>
      <dd>
       <p>
        The maximum size of files that the process may
            create. Attempts to extend a file beyond this limit
            result in delivery of a
        <code class="constant">
         SIGXFSZ
        </code>
        signal. By default, this
            signal terminates a process, but a process can catch
            this signal instead, in which case the relevant system
            call (e.g.,
        <a class="link" href="../htmlman2/write.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           write
          </span>
          (2)
         </span>
        </a>
        ,
        <a class="link" href="../htmlman2/truncate.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           truncate
          </span>
          (2)
         </span>
        </a>
        ) fails
            with the error
        <span class="errorname">
         EFBIG
        </span>
        .
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_LOCKS
        </code>
        (Early Linux 2.4
          only)
       </span>
      </dt>
      <dd>
       <p>
        A limit on the combined number of
        <a class="link" href="../htmlman2/flock.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           flock
          </span>
          (2)
         </span>
        </a>
        locks and
        <a class="link" href="../htmlman2/fcntl.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           fcntl
          </span>
          (2)
         </span>
        </a>
        leases that
            this process may establish.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_MEMLOCK
        </code>
       </span>
      </dt>
      <dd>
       <p>
        The maximum number of bytes of memory that may be
            locked into RAM. In effect this limit is rounded down
            to the nearest multiple of the system page size. This
            limit affects
        <a class="link" href="../htmlman2/mlock.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mlock
          </span>
          (2)
         </span>
        </a>
        and
        <a class="link" href="../htmlman2/mlock.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mlockall
          </span>
          (2)
         </span>
        </a>
        and the
        <a class="link" href="../htmlman2/mmap.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mmap
          </span>
          (2)
         </span>
        </a>
        <code class="constant">
         MAP_LOCKED
        </code>
        operation. Since Linux
            2.6.9 it also affects the
        <a class="link" href="../htmlman2/shmctl.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           shmctl
          </span>
          (2)
         </span>
        </a>
        <code class="constant">
         SHM_LOCK
        </code>
        operation, where
            it sets a maximum on the total bytes in shared memory
            segments (see
        <a class="link" href="../htmlman2/shmget.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           shmget
          </span>
          (2)
         </span>
        </a>
        ) that may
            be locked by the real user ID of the calling process.
            The
        <a class="link" href="../htmlman2/shmctl.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           shmctl
          </span>
          (2)
         </span>
        </a>
        <code class="constant">
         SHM_LOCK
        </code>
        locks are
            accounted for separately from the per-process memory
            locks established by
        <a class="link" href="../htmlman2/mlock.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mlock
          </span>
          (2)
         </span>
        </a>
        ,
        <a class="link" href="../htmlman2/mlock.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mlockall
          </span>
          (2)
         </span>
        </a>
        , and
        <a class="link" href="../htmlman2/mmap.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mmap
          </span>
          (2)
         </span>
        </a>
        <code class="constant">
         MAP_LOCKED
        </code>
        ; a process can lock bytes
            up to this limit in each of these two categories. In
            Linux kernels before 2.6.9, this limit controlled the
            amount of memory that could be locked by a privileged
            process. Since Linux 2.6.9, no limits are placed on the
            amount of memory that a privileged process may lock,
            and this limit instead governs the amount of memory
            that an unprivileged process may lock.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_MSGQUEUE
        </code>
        (since Linux
          2.6.8)
       </span>
      </dt>
      <dd>
       <p>
        Specifies the limit on the number of bytes that can
            be allocated for POSIX message queues for the real user
            ID of the calling process. This limit is enforced for
        <a class="link" href="../htmlman3/mq_open.3.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mq_open
          </span>
          (3)
         </span>
        </a>
        . Each
            message queue that the user creates counts (until it is
            removed) against this limit according to the
            formula:
       </p>
       <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
    bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
            attr.mq_maxmsg * attr.mq_msgsize
</pre>
       </div>
       <p>
        where
        <em class="replaceable">
         <code>
          attr
         </code>
        </em>
        is the
        <em class="replaceable">
         <code>
          mq_attr
         </code>
        </em>
        structure
            specified as the fourth argument to
        <a class="link" href="../htmlman3/mq_open.3.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           mq_open
          </span>
          (3)
         </span>
        </a>
        .
       </p>
       <p>
        The first addend in the formula, which includes
        <span class="emphasis">
         <em>
          sizeof(struct msg_msg
            *)
         </em>
        </span>
        (4 bytes on Linux/i386), ensures that
            the user cannot create an unlimited number of
            zero-length messages (such messages nevertheless each
            consume some system memory for bookkeeping
            overhead).
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_NICE
        </code>
        (since Linux 2.6.12, but
          see BUGS below)
       </span>
      </dt>
      <dd>
       <p>
        Specifies a ceiling to which the process's nice
            value can be raised using
        <a class="link" href="../htmlman2/getpriority.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           setpriority
          </span>
          (2)
         </span>
        </a>
        or
        <a class="link" href="../htmlman2/nice.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           nice
          </span>
          (2)
         </span>
        </a>
        . The actual
            ceiling for the nice value is calculated as
        <span class="emphasis">
         <em>
          20 &minus;
            rlim_cur
         </em>
        </span>
        . (This strangeness occurs because
            negative numbers cannot be specified as resource limit
            values, since they typically have special meanings. For
            example,
        <code class="constant">
         RLIM_INFINITY
        </code>
        typically is the same as &minus;1.)
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_NOFILE
        </code>
       </span>
      </dt>
      <dd>
       <p>
        Specifies a value one greater than the maximum file
            descriptor number that can be opened by this process.
            Attempts (
        <a class="link" href="../htmlman2/open.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           open
          </span>
          (2)
         </span>
        </a>
        ,
        <a class="link" href="../htmlman2/pipe.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           pipe
          </span>
          (2)
         </span>
        </a>
        ,
        <a class="link" href="../htmlman2/dup.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           dup
          </span>
          (2)
         </span>
        </a>
        , etc.) to
            exceed this limit yield the error
        <span class="errorname">
         EMFILE
        </span>
        . (Historically, this limit
            was named
        <code class="constant">
         RLIMIT_OFILE
        </code>
        on
            BSD.)
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_NPROC
        </code>
       </span>
      </dt>
      <dd>
       <p>
        The maximum number of processes (or, more precisely
            on Linux, threads) that can be created for the real
            user ID of the calling process. Upon encountering this
            limit,
        <a class="link" href="../htmlman2/fork.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           fork
          </span>
          (2)
         </span>
        </a>
        fails with
            the error
        <span class="errorname">
         EAGAIN
        </span>
        . This
            limit is not enforced for processes that have either
            the
        <code class="constant">
         CAP_SYS_ADMIN
        </code>
        or the
        <code class="constant">
         CAP_SYS_RESOURCE
        </code>
        capability.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_RSS
        </code>
       </span>
      </dt>
      <dd>
       <p>
        Specifies the limit (in pages) of the process's
            resident set (the number of virtual pages resident in
            RAM). This limit has effect only in Linux 2.4.x, x &lt;
            30, and there affects only calls to
        <a class="link" href="../htmlman2/madvise.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           madvise
          </span>
          (2)
         </span>
        </a>
        specifying
        <code class="constant">
         MADV_WILLNEED
        </code>
        .
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_RTPRIO
        </code>
        (since Linux 2.6.12, but
          see BUGS)
       </span>
      </dt>
      <dd>
       <p>
        Specifies a ceiling on the real-time priority that
            may be set for this process using
        <a class="link" href="../htmlman2/sched_setscheduler.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sched_setscheduler
          </span>
          (2)
         </span>
        </a>
        and
        <a class="link" href="../htmlman2/sched_setparam.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sched_setparam
          </span>
          (2)
         </span>
        </a>
        .
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_RTTIME
        </code>
        (since Linux
          2.6.25)
       </span>
      </dt>
      <dd>
       <p>
        Specifies a limit (in microseconds) on the amount of
            CPU time that a process scheduled under a real-time
            scheduling policy may consume without making a blocking
            system call. For the purpose of this limit, each time a
            process makes a blocking system call, the count of its
            consumed CPU time is reset to zero. The CPU time count
            is not reset if the process continues trying to use the
            CPU but is preempted, its time slice expires, or it
            calls
        <a class="link" href="../htmlman2/sched_yield.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sched_yield
          </span>
          (2)
         </span>
        </a>
        .
       </p>
       <p>
        Upon reaching the soft limit, the process is sent a
        <code class="constant">
         SIGXCPU
        </code>
        signal. If the
            process catches or ignores this signal and continues
            consuming CPU time, then
        <code class="constant">
         SIGXCPU
        </code>
        will be generated once each
            second until the hard limit is reached, at which point
            the process is sent a
        <code class="constant">
         SIGKILL
        </code>
        signal.
       </p>
       <p>
        The intended use of this limit is to stop a runaway
            real-time process from locking up the system.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_SIGPENDING
        </code>
        (since Linux
          2.6.8)
       </span>
      </dt>
      <dd>
       <p>
        Specifies the limit on the number of signals that
            may be queued for the real user ID of the calling
            process. Both standard and real-time signals are
            counted for the purpose of checking this limit.
            However, the limit is enforced only for
        <a class="link" href="../htmlman3/sigqueue.3.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sigqueue
          </span>
          (3)
         </span>
        </a>
        ; it is
            always possible to use
        <a class="link" href="../htmlman2/kill.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           kill
          </span>
          (2)
         </span>
        </a>
        to queue one
            instance of any of the signals that are not already
            queued to the process.
       </p>
      </dd>
      <dt>
       <span class="term">
        <code class="constant">
         RLIMIT_STACK
        </code>
       </span>
      </dt>
      <dd>
       <p>
        The maximum size of the process stack, in bytes.
            Upon reaching this limit, a
        <code class="constant">
         SIGSEGV
        </code>
        signal is generated. To
            handle this signal, a process must employ an alternate
            signal stack (
        <a class="link" href="../htmlman2/sigaltstack.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           sigaltstack
          </span>
          (2)
         </span>
        </a>
        ).
       </p>
       <p>
        Since Linux 2.6.23, this limit also determines the
            amount of space used for the process's command-line
            arguments and environment variables; for details, see
        <a class="link" href="../htmlman2/execve.2.html" shape="rect" target="_top">
         <span class="citerefentry">
          <span class="refentrytitle">
           execve
          </span>
          (2)
         </span>
        </a>
        .
       </p>
      </dd>
     </dl>
    </div>
    <div class="refsect2">
     <a id="getrlimit-2_sect2" name="getrlimit-2_sect2" shape="rect">
     </a>
     <h3>
      prlimit()
     </h3>
     <p>
      The Linux-specific
      <code class="function">
       prlimit
      </code>
      () system call combines and
        extends the functionality of
      <code class="function">
       setrlimit
      </code>
      () and
      <code class="function">
       getrlimit
      </code>
      (). It can be used to both set
        and get the resource limits of an arbitrary process.
     </p>
     <p>
      The
      <em class="parameter">
       <code>
        resource
       </code>
      </em>
      argument has the same meaning as for
      <code class="function">
       setrlimit
      </code>
      () and
      <code class="function">
       getrlimit
      </code>
      ().
     </p>
     <p>
      If the
      <em class="parameter">
       <code>
        new_limit
       </code>
      </em>
      argument is a not NULL, then the
      <span class="structname">
       rlimit
      </span>
      structure to which it points is
        used to set new values for the soft and hard limits for
      <em class="parameter">
       <code>
        resource
       </code>
      </em>
      . If the
      <em class="parameter">
       <code>
        old_limit
       </code>
      </em>
      argument
        is a not NULL, then a successful call to
      <code class="function">
       prlimit
      </code>
      () places the previous soft and
        hard limits for
      <em class="parameter">
       <code>
        resource
       </code>
      </em>
      in the
      <span class="structname">
       rlimit
      </span>
      structure pointed to by
      <em class="parameter">
       <code>
        old_limit
       </code>
      </em>
      .
     </p>
     <p>
      The
      <em class="parameter">
       <code>
        pid
       </code>
      </em>
      argument
        specifies the ID of the process on which the call is to
        operate. If
      <em class="parameter">
       <code>
        pid
       </code>
      </em>
      is
        0, then the call applies to the calling process. To set or
        get the resources of a process other than itself, the
        caller must have the
      <code class="constant">
       CAP_SYS_RESOURCE
      </code>
      capability, or the real,
        effective, and saved set user IDs of the target process
        must match the real user ID of the caller
      <em class="replaceable">
       <code>
        and
       </code>
      </em>
      the real, effective,
        and saved set group IDs of the target process must match
        the real group ID of the caller.
     </p>
    </div>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect3" name="getrlimit-2_sect3" shape="rect">
    </a>
    <h2>
     RETURN VALUE
    </h2>
    <p>
     On success, these system calls return 0. On error,
      &minus;1 is returned, and
     <code class="varname">
      errno
     </code>
     is set appropriately.
    </p>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect4" name="getrlimit-2_sect4" shape="rect">
    </a>
    <h2>
     ERRORS
    </h2>
    <div class="variablelist">
     <dl class="variablelist">
      <dt>
       <span class="term">
        <span class="errorname">
         EFAULT
        </span>
       </span>
      </dt>
      <dd>
       <p>
        A pointer argument points to a location outside the
            accessible address space.
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EINVAL
        </span>
       </span>
      </dt>
      <dd>
       <p>
        The value specified in
        <em class="parameter">
         <code>
          resource
         </code>
        </em>
        is not valid;
            or, for
        <code class="function">
         setrlimit
        </code>
        () or
        <code class="function">
         prlimit
        </code>
        ():
        <em class="replaceable">
         <code>
          rlim&minus;&gt;rlim_cur
         </code>
        </em>
        was greater than
        <em class="replaceable">
         <code>
          rlim&minus;&gt;rlim_max
         </code>
        </em>
        .
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         EPERM
        </span>
       </span>
      </dt>
      <dd>
       <p>
        An unprivileged process tried to raise the hard
            limit; the
        <code class="constant">
         CAP_SYS_RESOURCE
        </code>
        capability is
            required to do this. Or, the caller tried to increase
            the hard
        <code class="constant">
         RLIMIT_NOFILE
        </code>
        limit above the current kernel maximum (
        <code class="constant">
         NR_OPEN
        </code>
        ). Or, the calling process did
            not have permission to set limits for the process
            specified by
        <em class="parameter">
         <code>
          pid
         </code>
        </em>
        .
       </p>
      </dd>
      <dt>
       <span class="term">
        <span class="errorname">
         ESRCH
        </span>
       </span>
      </dt>
      <dd>
       <p>
        Could not find a process with the ID specified in
        <em class="parameter">
         <code>
          pid
         </code>
        </em>
        .
       </p>
      </dd>
     </dl>
    </div>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect5" name="getrlimit-2_sect5" shape="rect">
    </a>
    <h2>
     VERSIONS
    </h2>
    <p>
     The
     <code class="function">
      prlimit
     </code>
     () system call is
      available since Linux 2.6.36. Library support is available
      since glibc 2.13.
    </p>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect6" name="getrlimit-2_sect6" shape="rect">
    </a>
    <h2>
     CONFORMING TO
    </h2>
    <p>
     <code class="function">
      getrlimit
     </code>
     (),
     <code class="function">
      setrlimit
     </code>
     (): SVr4, 4.3BSD,
      POSIX.1-2001.
    </p>
    <p>
     <code class="function">
      prlimit
     </code>
     ():
      Linux-specific.
    </p>
    <p>
     <code class="constant">
      RLIMIT_MEMLOCK
     </code>
     and
     <code class="constant">
      RLIMIT_NPROC
     </code>
     derive from BSD
      and are not specified in POSIX.1-2001; they are present on
      the BSDs and Linux, but on few other implementations.
     <code class="constant">
      RLIMIT_RSS
     </code>
     derives from BSD and
      is not specified in POSIX.1-2001; it is nevertheless present
      on most implementations.
     <code class="constant">
      RLIMIT_MSGQUEUE
     </code>
     ,
     <code class="constant">
      RLIMIT_NICE
     </code>
     ,
     <code class="constant">
      RLIMIT_RTPRIO
     </code>
     ,
     <code class="constant">
      RLIMIT_RTTIME
     </code>
     , and
     <code class="constant">
      RLIMIT_SIGPENDING
     </code>
     are Linux-specific.
    </p>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect7" name="getrlimit-2_sect7" shape="rect">
    </a>
    <h2>
     NOTES
    </h2>
    <p>
     A child process created via
     <a class="link" href="../htmlman2/fork.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        fork
       </span>
       (2)
      </span>
     </a>
     inherits its
      parent's resource limits. Resource limits are preserved
      across
     <a class="link" href="../htmlman2/execve.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        execve
       </span>
       (2)
      </span>
     </a>
     .
    </p>
    <p>
     Lowering the soft limit for a resource below the process's
      current consumption of that resource will succeed (but will
      prevent the process from further increasing its consumption
      of the resource).
    </p>
    <p>
     One can set the resource limits of the shell using the
      built-in
     <em class="replaceable">
      <code>
       ulimit
      </code>
     </em>
     command (
     <em class="replaceable">
      <code>
       limit
      </code>
     </em>
     in
     <span class="citerefentry">
      <span class="refentrytitle">
       csh
      </span>
      (1)
     </span>
     ). The shell's resource
      limits are inherited by the processes that it creates to
      execute commands.
    </p>
    <p>
     Since Linux 2.6.24, the resource limits of any process can
      be inspected via
     <code class="filename">
      /proc/[pid]/limits
     </code>
     ; see
     <a class="link" href="../htmlman5/proc.5.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        proc
       </span>
       (5)
      </span>
     </a>
     .
    </p>
    <p>
     Ancient systems provided a
     <code class="function">
      vlimit
     </code>
     () function with a similar purpose to
     <code class="function">
      setrlimit
     </code>
     (). For backward
      compatibility, glibc also provides
     <code class="function">
      vlimit
     </code>
     (). All new applications should be
      written using
     <code class="function">
      setrlimit
     </code>
     ().
    </p>
    <div class="refsect2">
     <a id="getrlimit-2_sect8" name="getrlimit-2_sect8" shape="rect">
     </a>
     <h3>
      C library/ kernel ABI differences
     </h3>
     <p>
      Since version 2.13, the glibc
      <code class="function">
       getrlimit
      </code>
      () and
      <code class="function">
       setrlimit
      </code>
      () wrapper functions no longer
        invoke the corresponding system calls, but instead employ
      <code class="function">
       prlimit
      </code>
      (), for the reasons
        described in BUGS.
     </p>
    </div>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect9" name="getrlimit-2_sect9" shape="rect">
    </a>
    <h2>
     BUGS
    </h2>
    <p>
     In older Linux kernels, the
     <code class="constant">
      SIGXCPU
     </code>
     and
     <code class="constant">
      SIGKILL
     </code>
     signals delivered when a process
      encountered the soft and hard
     <code class="constant">
      RLIMIT_CPU
     </code>
     limits were delivered one (CPU)
      second later than they should have been. This was fixed in
      kernel 2.6.8.
    </p>
    <p>
     In 2.6.x kernels before 2.6.17, a
     <code class="constant">
      RLIMIT_CPU
     </code>
     limit of 0 is wrongly treated as
      "no limit" (like
     <code class="constant">
      RLIM_INFINITY
     </code>
     ). Since Linux 2.6.17, setting
      a limit of 0 does have an effect, but is actually treated as
      a limit of 1 second.
    </p>
    <p>
     A kernel bug means that
     <code class="constant">
      RLIMIT_RTPRIO
     </code>
     does not work in kernel
      2.6.12; the problem is fixed in kernel 2.6.13.
    </p>
    <p>
     In kernel 2.6.12, there was an off-by-one mismatch between
      the priority ranges returned by
     <a class="link" href="../htmlman2/getpriority.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        getpriority
       </span>
       (2)
      </span>
     </a>
     and
     <code class="constant">
      RLIMIT_NICE
     </code>
     . This had the
      effect that the actual ceiling for the nice value was
      calculated as
     <span class="emphasis">
      <em>
       19 &minus;
      rlim_cur
      </em>
     </span>
     . This was fixed in kernel 2.6.13.
    </p>
    <p>
     Since Linux 2.6.12, if a process reaches its soft
     <code class="constant">
      RLIMIT_CPU
     </code>
     limit and has a
      handler installed for
     <code class="constant">
      SIGXCPU
     </code>
     ,
      then, in addition to invoking the signal handler, the kernel
      increases the soft limit by one second. This behavior repeats
      if the process continues to consume CPU time, until the hard
      limit is reached, at which point the process is killed. Other
      implementations do not change the
     <code class="constant">
      RLIMIT_CPU
     </code>
     soft limit in this manner, and
      the Linux behavior is probably not standards conformant;
      portable applications should avoid relying on this
      Linux-specific behavior. The Linux-specific
     <code class="constant">
      RLIMIT_RTTIME
     </code>
     limit exhibits the same
      behavior when the soft limit is encountered.
    </p>
    <p>
     Kernels before 2.4.22 did not diagnose the error
     <span class="errorname">
      EINVAL
     </span>
     for
     <code class="function">
      setrlimit
     </code>
     () when
     <em class="replaceable">
      <code>
       rlim&minus;&gt;rlim_cur
      </code>
     </em>
     was
      greater than
     <em class="replaceable">
      <code>
       rlim&minus;&gt;rlim_max
      </code>
     </em>
     .
    </p>
    <div class="refsect2">
     <a id="getrlimit-2_sect10" name="getrlimit-2_sect10" shape="rect">
     </a>
     <h3>
      Representation of "large" resource limit values on
        32-bit platforms
     </h3>
     <p>
      The glibc
      <code class="function">
       getrlimit
      </code>
      () and
      <code class="function">
       setrlimit
      </code>
      () wrapper functions
        use a 64-bit
      <span class="type">
       rlim_t
      </span>
      data type,
        even on 32-bit platforms. However, the
      <span class="type">
       rlim_t
      </span>
      data type used in the
      <code class="function">
       getrlimit
      </code>
      () and
      <code class="function">
       setrlimit
      </code>
      () system calls is a (32-bit)
      <span class="type">
       unsigned long
      </span>
      . Furthermore, in
        Linux versions before 2.6.36, the kernel represents
        resource limits on 32-bit platforms as
      <span class="type">
       unsigned long
      </span>
      . However, a 32-bit data type is
        not wide enough. The most pertinent limit here is
      <code class="constant">
       RLIMIT_FSIZE
      </code>
      , which specifies
        the maximum size to which a file can grow: to be useful,
        this limit must be represented using a type that is as wide
        as the type used to represent file offsets&mdash;that is,
        as wide as a 64-bit
      <span class="type">
       off_t
      </span>
      (assuming a program compiled with
      <em class="replaceable">
       <code>
        _FILE_OFFSET_BITS=64
       </code>
      </em>
      ).
     </p>
     <p>
      To work around this kernel limitation, if a program
        tried to set a resource limit to a value larger than can be
        represented in a 32-bit
      <span class="type">
       unsigned
        long
      </span>
      , then the glibc
      <code class="function">
       setrlimit
      </code>
      () wrapper function silently
        converted the limit value to
      <code class="constant">
       RLIM_INFINITY
      </code>
      . In other words, the
        requested resource limit setting was silently ignored.
     </p>
     <p>
      This problem was addressed in Linux 2.6.36 with two
        principal changes:
     </p>
     <div class="itemizedlist">
      <ul class="itemizedlist" style="list-style-type: disc;">
       <li class="listitem">
        <p>
         the addition of a new kernel representation of
              resource limits that uses 64 bits, even on 32-bit
              platforms;
        </p>
       </li>
       <li class="listitem">
        <p>
         the addition of the
         <code class="function">
          prlimit
         </code>
         () system call, which
              employs 64-bit values for its resource limit
              arguments.
        </p>
       </li>
      </ul>
     </div>
     <p>
      Since version 2.13, glibc works around the limitations
        of the
      <code class="function">
       getrlimit
      </code>
      () and
      <code class="function">
       setrlimit
      </code>
      () system calls by
        implementing
      <code class="function">
       setrlimit
      </code>
      () and
      <code class="function">
       getrlimit
      </code>
      () as wrapper
        functions that call
      <code class="function">
       prlimit
      </code>
      ().
     </p>
    </div>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect11" name="getrlimit-2_sect11" shape="rect">
    </a>
    <h2>
     EXAMPLE
    </h2>
    <p>
     The program below demonstrates the use of
     <code class="function">
      prlimit
     </code>
     ().
    </p>
    <div class="informalexample">
     <pre class="programlisting" xml:space="preserve">
#define _GNU_SOURCE
#define _FILE_OFFSET_BITS 64
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/resource.h&gt;

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

int
main(int argc, char *argv[])
{
    struct rlimit old, new;
    struct rlimit *newp;
    pid_t pid;

    if (!(argc == 2 || argc == 4)) {
        fprintf(stderr, "Usage: %s &lt;pid&gt; [&lt;new&minus;soft&minus;limit&gt; "
                "&lt;new&minus;hard&minus;limit&gt;]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid = atoi(argv[1]);        /* PID of target process */

    newp = NULL;
    if (argc == 4) {
        new.rlim_cur = atoi(argv[2]);
        new.rlim_max = atoi(argv[3]);
        newp = &amp;new;
    }

    /* Set CPU time limit of target process; retrieve and display
       previous limit */

    if (prlimit(pid, RLIMIT_CPU, newp, &amp;old) == &minus;1)
        errExit("prlimit&minus;1");
    printf("Previous limits: soft=%lld; hard=%lld\n",
            (long long) old.rlim_cur, (long long) old.rlim_max);

    /* Retrieve and display new CPU time limit */

    if (prlimit(pid, RLIMIT_CPU, NULL, &amp;old) == &minus;1)
        errExit("prlimit&minus;2");
    printf("New limits: soft=%lld; hard=%lld\n",
            (long long) old.rlim_cur, (long long) old.rlim_max);

    exit(EXIT_FAILURE);
}
</pre>
    </div>
   </div>
   <div class="refsect1">
    <a id="getrlimit-2_sect12" name="getrlimit-2_sect12" shape="rect">
    </a>
    <h2>
     SEE ALSO
    </h2>
    <p>
     <a class="link" href="../htmlman1/prlimit.1.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        prlimit
       </span>
       (1)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/dup.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        dup
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/fcntl.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        fcntl
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/fork.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        fork
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/getrusage.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        getrusage
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/mlock.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mlock
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/mmap.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        mmap
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/open.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        open
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/quotactl.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        quotactl
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/brk.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sbrk
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman2/shmctl.2.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        shmctl
       </span>
       (2)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/malloc.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        malloc
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/sigqueue.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        sigqueue
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/ulimit.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        ulimit
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman5/core.5.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        core
       </span>
       (5)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman7/capabilities.7.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        capabilities
       </span>
       (7)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman7/signal.7.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        signal
       </span>
       (7)
      </span>
     </a>
    </p>
   </div>
   <div class="colophon">
    <a id="getrlimit-2_sect13" name="getrlimit-2_sect13" shape="rect">
    </a>
    <h2>
     COLOPHON
    </h2>
    <p>
     This page is part of release 3.72 of the Linux
     <em class="replaceable">
      <code>
       man-pages
      </code>
     </em>
     project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      http://www.kernel.org/doc/man&minus;pages/.
    </p>
   </div>
  </div>
 </body>
</html>
