<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

  <title>pcreapi(3) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="pcreapi(3) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve">
</script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>

<body>

  <div class="refentry">
    <a id="pcreapi.3" name="pcreapi.3" shape="rect"> </a>

    <div class="titlepage"> </div>

    <div class="refnamediv">
      <h2>Name</h2>

      <p>PCRE — Perl-compatible regular expressions</p>
    </div>

    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
#include &lt;pcre.h&gt;
 PCRE NATIVE API BASIC FUNCTIONS
</pre>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre
            *<strong>pcre_compile</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre
            *<strong>pcre_compile2</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">errorcodeptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_extra
            *<strong>pcre_study</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_free_study</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre_extra *<var class="pdparam">extra</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_dfa_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">workspace</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">wscount</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <pre class="funcsynopsisinfo" xml:space="preserve">
PCRE NATIVE API STRING EXTRACTION FUNCTIONS
</pre>

        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_copy_named_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_copy_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_named_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_stringnumber</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_stringtable_entries</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">first</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">last</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_substring_list</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char ***<var class="pdparam">listptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_free_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_free_substring_list</strong>(</code></td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <pre class="funcsynopsisinfo" xml:space="preserve">
PCRE NATIVE API AUXILIARY FUNCTIONS
</pre>

        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_jit_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">pcre_jit_stack *<var class="pdparam">jstack</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_jit_stack
            *<strong>pcre_jit_stack_alloc</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">maxsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_jit_stack_free</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre_jit_stack *<var class="pdparam">stack</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_assign_jit_stack</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">pcre_jit_callback <var class="pdparam">callback</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">data</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">const unsigned char
            *<strong>pcre_maketables</strong>(</code></td>

            <td rowspan="1" colspan="1"><code>void)</code>;</td>

            <td rowspan="1" colspan="1"> </td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_fullinfo</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_refcount</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">adjust</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_config</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">const char
            *<strong>pcre_version</strong>(</code></td>

            <td rowspan="1" colspan="1"><code>void)</code>;</td>

            <td rowspan="1" colspan="1"> </td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_pattern_to_host_byte_order</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tables</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <pre class="funcsynopsisinfo" xml:space="preserve">
PCRE NATIVE API INDIRECTED FUNCTIONS
</pre>

        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>*</strong>(</code></td>

            <td rowspan="1" colspan="1">*pcre_malloc)(<var class="pdparam">size_t</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>void</strong>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_free)(void
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>*</strong>(</code></td>

            <td rowspan="1" colspan="1">*pcre_stack_malloc)(<var class="pdparam">size_t</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>void</strong>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_stack_free)(void
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>int</strong>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_callout)(pcre_callout_block
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>int</strong>(</code></td>

            <td rowspan="1" colspan="1">*pcre_stack_guard)(<var class="pdparam">void</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect1" name="pcreapi-3_sect1" shape="rect"> </a>

      <h2>PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</h2>

      <p>As well as support for 8-bit character strings, PCRE also
      supports 16-bit strings (from release 8.30) and 32-bit
      strings (from release 8.32), by means of two additional
      libraries. They can be built as well as, or instead of, the
      8-bit library. To avoid too much complication, this document
      describes the 8-bit versions of the functions, with only
      occasional references to the 16-bit and 32-bit libraries.</p>

      <p>The 16-bit and 32-bit functions operate in the same way as
      their 8-bit counterparts; they just use different data types
      for their arguments and results, and their names start with
      <code class="function">pcre16_</code> or <code class="function">pcre32_</code> instead of <code class="function">pcre_</code>. For every option that has UTF8 in
      its name (for example, PCRE_UTF8), there are corresponding
      16-bit and 32-bit names with UTF8 replaced by UTF16 or UTF32,
      respectively. This facility is in fact just cosmetic; the
      16-bit and 32-bit option names define the same bit
      values.</p>

      <p>References to bytes and UTF-8 in this document should be
      read as references to 16-bit data units and UTF-16 when using
      the 16-bit library, or 32-bit data units and UTF-32 when
      using the 32-bit library, unless specified otherwise. More
      details of the specific differences for the 16-bit and 32-bit
      libraries are given in the <a class="link" href="../htmlman3/pcre16.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre16</span>(3)</span></a> and <a class="link" href="../htmlman3/pcre32.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre32</span>(3)</span></a> pages.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect2" name="pcreapi-3_sect2" shape="rect"> </a>

      <h2>PCRE API OVERVIEW</h2>

      <p>PCRE has its own native API, which is described in this
      document. There are also some wrapper functions (for the
      8-bit library only) that correspond to the POSIX regular
      expression API, but they do not give access to all the
      functionality. They are described in the <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a> documentation.
      Both of these APIs define a set of C function calls. A C++
      wrapper (again for the 8-bit library only) is also
      distributed with PCRE. It is documented in the <a class="link" href="../htmlman3/pcrecpp.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecpp</span>(3)</span></a> page.</p>

      <p>The native API C function prototypes are defined in the
      header file <code class="filename">pcre.h</code>, and on
      Unix-like systems the (8-bit) library itself is called
      <em class="citetitle">libpcre</em>. It can normally be
      accessed by adding <code class="option">−lpcre</code>
      to the command for linking an application that uses PCRE. The
      header file defines the macros PCRE_MAJOR and PCRE_MINOR to
      contain the major and minor release numbers for the library.
      Applications can use these to include support for different
      releases of PCRE.</p>

      <p>In a Windows environment, if you want to statically link
      an application program against a non-dll <em class="replaceable"><code>pcre.a</code></em> file, you must define
      PCRE_STATIC before including <code class="filename">pcre.h</code> or <code class="filename">pcrecpp.h</code>, because otherwise the
      <code class="function">pcre_malloc</code>() and <code class="function">pcre_free</code>() exported functions will be
      declared <em class="replaceable"><code>__declspec(dllimport)</code></em>, with
      unwanted results.</p>

      <p>The functions <code class="function">pcre_compile</code>(), <code class="function">pcre_compile2</code>(), <code class="function">pcre_study</code>(), and <code class="function">pcre_exec</code>() are used for compiling and
      matching regular expressions in a Perl-compatible manner. A
      sample program that demonstrates the simplest way of using
      them is provided in the file called <code class="filename">pcredemo.c</code> in the PCRE source distribution.
      A listing of this program is given in the <a class="link" href="../htmlman3/pcredemo.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span></a> documentation,
      and the <a class="link" href="../htmlman3/pcresample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcresample</span>(3)</span></a> documentation
      describes how to compile and run it.</p>

      <p>Just-in-time compiler support is an optional feature of
      PCRE that can be built in appropriate hardware environments.
      It greatly speeds up the matching performance of many
      patterns. Simple programs can easily request that it be used
      if available, by setting an option that is ignored when it is
      not relevant. More complicated programs might need to make
      use of the functions <code class="function">pcre_jit_stack_alloc</code>(), <code class="function">pcre_jit_stack_free</code>(), and <code class="function">pcre_assign_jit_stack</code>() in order to control
      the JIT code's memory usage.</p>

      <p>From release 8.32 there is also a direct interface for JIT
      execution, which gives improved performance. The JIT-specific
      functions are discussed in the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a>
      documentation.</p>

      <p>A second matching function, <code class="function">pcre_dfa_exec</code>(), which is not
      Perl-compatible, is also provided. This uses a different
      algorithm for the matching. The alternative algorithm finds
      all possible matches (at a given point in the subject), and
      scans the subject just once (unless there are lookbehind
      assertions). However, this algorithm does not return captured
      substrings. A description of the two matching algorithms and
      their advantages and disadvantages is given in the <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>
      documentation.</p>

      <p>In addition to the main compiling and matching functions,
      there are convenience functions for extracting captured
      substrings from a subject string that is matched by
      <code class="function">pcre_exec</code>(). They are:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 <code class="function">pcre_copy_substring</code>()
 <code class="function">pcre_copy_named_substring</code>()
 <code class="function">pcre_get_substring</code>()
 <code class="function">pcre_get_named_substring</code>()
 <code class="function">pcre_get_substring_list</code>()
 <code class="function">pcre_get_stringnumber</code>()
 <code class="function">pcre_get_stringtable_entries</code>()
</pre>
      </div>

      <p><code class="function">pcre_free_substring</code>() and
      <code class="function">pcre_free_substring_list</code>() are
      also provided, to free the memory used for extracted
      strings.</p>

      <p>The function <code class="function">pcre_maketables</code>() is used to build a set of
      character tables in the current locale for passing to
      <code class="function">pcre_compile</code>(), <code class="function">pcre_exec</code>(), or <code class="function">pcre_dfa_exec</code>(). This is an optional
      facility that is provided for specialist use. Most commonly,
      no special tables are passed, in which case internal tables
      that are generated when PCRE is built are used.</p>

      <p>The function <code class="function">pcre_fullinfo</code>()
      is used to find out information about a compiled pattern. The
      function <code class="function">pcre_version</code>() returns
      a pointer to a string containing the version of PCRE and its
      date of release.</p>

      <p>The function <code class="function">pcre_refcount</code>()
      maintains a reference count in a data block containing a
      compiled pattern. This is provided for the benefit of
      object-oriented applications.</p>

      <p>The global variables <code class="function">pcre_malloc</code> and <code class="function">pcre_free</code> initially contain the entry
      points of the standard <code class="function">malloc</code>()
      and <code class="function">free</code>() functions,
      respectively. PCRE calls the memory management functions via
      these variables, so a calling program can replace them if it
      wishes to intercept the calls. This should be done before
      calling any PCRE functions.</p>

      <p>The global variables <code class="function">pcre_stack_malloc</code> and <code class="function">pcre_stack_free</code> are also indirections to
      memory management functions. These special functions are used
      only when PCRE is compiled to use the heap for remembering
      data, instead of recursive function calls, when running the
      <code class="function">pcre_exec</code>() function. See the
      <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a> documentation
      for details of how to do this. It is a non-standard way of
      building PCRE, for use in environments that have limited
      stacks. Because of the greater use of memory management, it
      runs more slowly. Separate functions are provided so that
      special-purpose external code can be used for this case. When
      used, these functions are always called in a stack-like
      manner (last obtained, first freed), and always for memory
      blocks of the same size. There is a discussion about PCRE's
      stack usage in the <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a>
      documentation.</p>

      <p>The global variable <code class="function">pcre_callout</code> initially contains NULL. It
      can be set by the caller to a "callout" function, which PCRE
      will then call at specified points during a matching
      operation. Details are given in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>

      <p>The global variable <code class="function">pcre_stack_guard</code> initially contains NULL.
      It can be set by the caller to a function that is called by
      PCRE whenever it starts to compile a parenthesized part of a
      pattern. When parentheses are nested, PCRE uses recursive
      function calls, which use up the system stack. This function
      is provided so that applications with restricted stacks can
      force a compilation error if the stack runs out. The function
      should return zero if all is well, or non-zero to force an
      error.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect3" name="pcreapi-3_sect3" shape="rect"> </a>

      <h2>NEWLINES</h2>

      <p>PCRE supports five different conventions for indicating
      line breaks in strings: a single CR (carriage return)
      character, a single LF (linefeed) character, the
      two-character sequence CRLF, any of the three preceding, or
      any Unicode newline sequence. The Unicode newline sequences
      are the three just mentioned, plus the single characters VT
      (vertical tab, U+000B), FF (form feed, U+000C), NEL (next
      line, U+0085), LS (line separator, U+2028), and PS (paragraph
      separator, U+2029).</p>

      <p>Each of the first three conventions is used by at least
      one operating system as its standard newline sequence. When
      PCRE is built, a default can be specified. The default
      default is LF, which is the Unix standard. When PCRE is run,
      the default can be overridden, either when a pattern is
      compiled, or when it is matched.</p>

      <p>At compile time, the newline convention can be specified
      by the <em class="parameter"><code>options</code></em>
      argument of <code class="function">pcre_compile</code>(), or
      it can be specified by special text at the start of the
      pattern itself; this overrides any other settings. See the
      <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page for
      details of the special character sequences.</p>

      <p>In the PCRE documentation the word "newline" is used to
      mean "the character or pair of characters that indicate a
      line break". The choice of newline convention affects the
      handling of the dot, circumflex, and dollar metacharacters,
      the handling of #-comments in /x mode, and, when CRLF is a
      recognized line ending sequence, the match position
      advancement for a non-anchored pattern. There is more detail
      about this in the section on <code class="function">pcre_exec</code>() options below.</p>

      <p>The choice of newline convention does not affect the
      interpretation of the \n or \r escape sequences, nor does it
      affect what \R matches, which is controlled in a similar way,
      but by separate options.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect4" name="pcreapi-3_sect4" shape="rect"> </a>

      <h2>MULTITHREADING</h2>

      <p>The PCRE functions can be used in multi-threading
      applications, with the proviso that the memory management
      functions pointed to by <code class="function">pcre_malloc</code>, <code class="function">pcre_free</code>, <code class="function">pcre_stack_malloc</code>, and <code class="function">pcre_stack_free</code>, and the callout and
      stack-checking functions pointed to by <code class="function">pcre_callout</code> and <code class="function">pcre_stack_guard</code>, are shared by all
      threads.</p>

      <p>The compiled form of a regular expression is not altered
      during matching, so the same compiled pattern can safely be
      used by several threads at once.</p>

      <p>If the just-in-time optimization feature is being used, it
      needs separate memory stack areas for each thread. See the
      <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a> documentation
      for more details.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect5" name="pcreapi-3_sect5" shape="rect"> </a>

      <h2>SAVING PRECOMPILED PATTERNS FOR LATER USE</h2>

      <p>The compiled form of a regular expression can be saved and
      re-used at a later time, possibly by a different program, and
      even on a host other than the one on which it was compiled.
      Details are given in the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation, which includes a description of the
      <code class="function">pcre_pattern_to_host_byte_order</code>() function.
      However, compiling a regular expression with one version of
      PCRE for use with a different version is not guaranteed to
      work and may cause crashes.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect6" name="pcreapi-3_sect6" shape="rect"> </a>

      <h2>CHECKING BUILD-TIME OPTIONS</h2>

      <p><span class="emphasis"><em>int pcre_config(int <em class="parameter"><code>what</code></em>, void *<em class="parameter"><code>where</code></em>);</em></span></p>

      <p>The function <code class="function">pcre_config</code>()
      makes it possible for a PCRE client to discover which
      optional features have been compiled into the PCRE library.
      The <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a> documentation
      has more details about these optional features.</p>

      <p>The first argument for <code class="function">pcre_config</code>() is an integer, specifying
      which information is required; the second argument is a
      pointer to a variable into which the information is placed.
      The returned value is zero on success, or the negative error
      code PCRE_ERROR_BADOPTION if the value in the first argument
      is not recognized. The following information is
      available:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_UTF8
</pre>
      </div>

      <p>The output is an integer that is set to one if UTF-8
      support is available; otherwise it is set to zero. This value
      should normally be given to the 8-bit version of this
      function, <code class="function">pcre_config</code>(). If it
      is given to the 16-bit or 32-bit version of this function,
      the result is PCRE_ERROR_BADOPTION.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_UTF16
</pre>
      </div>

      <p>The output is an integer that is set to one if UTF-16
      support is available; otherwise it is set to zero. This value
      should normally be given to the 16-bit version of this
      function, <code class="function">pcre16_config</code>(). If
      it is given to the 8-bit or 32-bit version of this function,
      the result is PCRE_ERROR_BADOPTION.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_UTF32
</pre>
      </div>

      <p>The output is an integer that is set to one if UTF-32
      support is available; otherwise it is set to zero. This value
      should normally be given to the 32-bit version of this
      function, <code class="function">pcre32_config</code>(). If
      it is given to the 8-bit or 16-bit version of this function,
      the result is PCRE_ERROR_BADOPTION.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_UNICODE_PROPERTIES
</pre>
      </div>

      <p>The output is an integer that is set to one if support for
      Unicode character properties is available; otherwise it is
      set to zero.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_JIT
</pre>
      </div>

      <p>The output is an integer that is set to one if support for
      just-in-time compiling is available; otherwise it is set to
      zero.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_JITTARGET
</pre>
      </div>

      <p>The output is a pointer to a zero-terminated "const char
      *" string. If JIT support is available, the string contains
      the name of the architecture for which the JIT compiler is
      configured, for example "x86 32bit (little endian +
      unaligned)". If JIT support is not available, the result is
      NULL.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_NEWLINE
</pre>
      </div>

      <p>The output is an integer whose value specifies the default
      character sequence that is recognized as meaning "newline".
      The values that are supported in ASCII/Unicode environments
      are: 10 for LF, 13 for CR, 3338 for CRLF, -2 for ANYCRLF, and
      -1 for ANY. In EBCDIC environments, CR, ANYCRLF, and ANY
      yield the same values. However, the value for LF is normally
      21, though some EBCDIC environments use 37. The corresponding
      values for CRLF are 3349 and 3365. The default should
      normally correspond to the standard sequence for your
      operating system.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_BSR
</pre>
      </div>

      <p>The output is an integer whose value indicates what
      character sequences the \R escape sequence matches by
      default. A value of 0 means that \R matches any Unicode line
      ending sequence; a value of 1 means that \R matches only CR,
      LF, or CRLF. The default can be overridden when a pattern is
      compiled or matched.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_LINK_SIZE
</pre>
      </div>

      <p>The output is an integer that contains the number of bytes
      used for internal linkage in compiled regular expressions.
      For the 8-bit library, the value can be 2, 3, or 4. For the
      16-bit library, the value is either 2 or 4 and is still a
      number of bytes. For the 32-bit library, the value is either
      2 or 4 and is still a number of bytes. The default value of 2
      is sufficient for all but the most massive patterns, since it
      allows the compiled pattern to be up to 64K in size. Larger
      values allow larger regular expressions to be compiled, at
      the expense of slower matching.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_POSIX_MALLOC_THRESHOLD
</pre>
      </div>

      <p>The output is an integer that contains the threshold above
      which the POSIX interface uses <code class="function">malloc</code>() for output vectors. Further
      details are given in the <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a>
      documentation.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_PARENS_LIMIT
</pre>
      </div>

      <p>The output is a long integer that gives the maximum depth
      of nesting of parentheses (of any kind) in a pattern. This
      limit is imposed to cap the amount of system stack used when
      a pattern is compiled. It is specified when PCRE is built;
      the default is 250. This limit does not take into account the
      stack that may already be used by the calling application.
      For finer control over compilation stack usage, you can set a
      pointer to an external checking function in <code class="function">pcre_stack_guard</code>.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_MATCH_LIMIT
</pre>
      </div>

      <p>The output is a long integer that gives the default limit
      for the number of internal matching function calls in a
      <code class="function">pcre_exec</code>() execution. Further
      details are given with <code class="function">pcre_exec</code>() below.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_MATCH_LIMIT_RECURSION
</pre>
      </div>

      <p>The output is a long integer that gives the default limit
      for the depth of recursion when calling the internal matching
      function in a <code class="function">pcre_exec</code>()
      execution. Further details are given with <code class="function">pcre_exec</code>() below.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CONFIG_STACKRECURSE
</pre>
      </div>

      <p>The output is an integer that is set to one if internal
      recursion when running <code class="function">pcre_exec</code>() is implemented by recursive
      function calls that use the stack to remember their state.
      This is the usual way that PCRE is compiled. The output is
      zero if PCRE was compiled to use blocks of data on the heap
      instead of recursive function calls. In this case,
      <code class="function">pcre_stack_malloc</code> and
      <code class="function">pcre_stack_free</code> are called to
      manage memory blocks on the heap, thus avoiding the use of
      the stack.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect7" name="pcreapi-3_sect7" shape="rect"> </a>

      <h2>COMPILING A PATTERN</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre *pcre_compile(const char *<em class="parameter"><code>pattern</code></em>, int <em class="parameter"><code>options</code></em>,</em></span>
<span class="emphasis"><em>     const char **<em class="parameter"><code>errptr</code></em>, int *<em class="parameter"><code>erroffset</code></em>,</em></span>
<span class="emphasis"><em>     const unsigned char *<em class="parameter"><code>tableptr</code></em>);</em></span>

<span class="emphasis"><em>pcre *pcre_compile2(const char *<em class="parameter"><code>pattern</code></em>, int <em class="parameter"><code>options</code></em>,</em></span>
<span class="emphasis"><em>     int *<em class="parameter"><code>errorcodeptr</code></em>,</em></span>
<span class="emphasis"><em>     const char **<em class="parameter"><code>errptr</code></em>, int *<em class="parameter"><code>erroffset</code></em>,</em></span>
<span class="emphasis"><em>     const unsigned char *<em class="parameter"><code>tableptr</code></em>);</em></span>
</pre>
      </div>

      <p>Either of the functions <code class="function">pcre_compile</code>() or <code class="function">pcre_compile2</code>() can be called to compile a
      pattern into an internal form. The only difference between
      the two interfaces is that <code class="function">pcre_compile2</code>() has an additional argument,
      <em class="parameter"><code>errorcodeptr</code></em>, via
      which a numerical error code can be returned. To avoid too
      much repetition, we refer just to <code class="function">pcre_compile</code>() below, but the information
      applies equally to <code class="function">pcre_compile2</code>().</p>

      <p>The pattern is a C string terminated by a binary zero, and
      is passed in the <em class="parameter"><code>pattern</code></em> argument. A pointer to
      a single block of memory that is obtained via <code class="function">pcre_malloc</code> is returned. This contains the
      compiled code and related data. The <code class="function">pcre</code> type is defined for the returned
      block; this is a typedef for a structure whose contents are
      not externally defined. It is up to the caller to free the
      memory (via <code class="function">pcre_free</code>) when it
      is no longer required.</p>

      <p>Although the compiled code of a PCRE regex is relocatable,
      that is, it does not depend on memory location, the complete
      <code class="function">pcre</code> data block is not fully
      relocatable, because it may contain a copy of the <em class="parameter"><code>tableptr</code></em> argument, which is an
      address (see below).</p>

      <p>The <em class="parameter"><code>options</code></em>
      argument contains various bit settings that affect the
      compilation. It should be zero if no options are required.
      The available options are described below. Some of them (in
      particular, those that are compatible with Perl, but some
      others as well) can also be set and unset from within the
      pattern (see the detailed description in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation). For those options that can be different in
      different parts of the pattern, the contents of the
      <em class="parameter"><code>options</code></em> argument
      specifies their settings at the start of compilation and
      execution. The PCRE_ANCHORED, PCRE_BSR_<code class="function">xxx</code>, PCRE_NEWLINE_<code class="function">xxx</code>, PCRE_NO_UTF8_CHECK, and
      PCRE_NO_START_OPTIMIZE options can be set at the time of
      matching as well as at compile time.</p>

      <p>If <em class="parameter"><code>errptr</code></em> is NULL,
      <code class="function">pcre_compile</code>() returns NULL
      immediately. Otherwise, if compilation of a pattern fails,
      <code class="function">pcre_compile</code>() returns NULL,
      and sets the variable pointed to by <em class="parameter"><code>errptr</code></em> to point to a textual
      error message. This is a static string that is part of the
      library. You must not try to free it. Normally, the offset
      from the start of the pattern to the data unit that was being
      processed when the error was discovered is placed in the
      variable pointed to by <em class="parameter"><code>erroffset</code></em>, which must not be
      NULL (if it is, an immediate error is given). However, for an
      invalid UTF-8 or UTF-16 string, the offset is that of the
      first data unit of the failing character.</p>

      <p>Some errors are not detected until the whole pattern has
      been scanned; in these cases, the offset passed back is the
      length of the pattern. Note that the offset is in data units,
      not characters, even in a UTF mode. It may sometimes point
      into the middle of a UTF-8 or UTF-16 character.</p>

      <p>If <code class="function">pcre_compile2</code>() is used
      instead of <code class="function">pcre_compile</code>(), and
      the <em class="parameter"><code>errorcodeptr</code></em>
      argument is not NULL, a non-zero error code number is
      returned via this argument in the event of an error. This is
      in addition to the textual error message. Error codes and
      messages are listed below.</p>

      <p>If the final argument, <em class="parameter"><code>tableptr</code></em>, is NULL, PCRE uses a
      default set of character tables that are built when PCRE is
      compiled, using the default C locale. Otherwise, <em class="parameter"><code>tableptr</code></em> must be an address
      that is the result of a call to <code class="function">pcre_maketables</code>(). This value is stored
      with the compiled pattern, and used again by <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>() when the pattern is
      matched. For more discussion, see the section on locale
      support below.</p>

      <p>This code fragment shows a typical straightforward call to
      <code class="function">pcre_compile</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 pcre *re;
 const char *error;
 int erroffset;
 re = pcre_compile(
   "^A.*Z",          /* the pattern */
   0,                /* default options */
   &amp;error,           /* for error message */
   &amp;erroffset,       /* for error offset */
   NULL);            /* use default character tables */
</pre>
      </div>

      <p>The following names for option bits are defined in the
      <code class="filename">pcre.h</code> header file:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ANCHORED
</pre>
      </div>

      <p>If this bit is set, the pattern is forced to be
      "anchored", that is, it is constrained to match only at the
      first matching point in the string that is being searched
      (the "subject string"). This effect can also be achieved by
      appropriate constructs in the pattern itself, which is the
      only way to do it in Perl.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_AUTO_CALLOUT
</pre>
      </div>

      <p>If this bit is set, <code class="function">pcre_compile</code>() automatically inserts
      callout items, all with number 255, before each pattern item.
      For discussion of the callout facility, see the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_BSR_ANYCRLF
 PCRE_BSR_UNICODE
</pre>
      </div>

      <p>These options (which are mutually exclusive) control what
      the \R escape sequence matches. The choice is either to match
      only CR, LF, or CRLF, or to match any Unicode newline
      sequence. The default is specified when PCRE is built. It can
      be overridden from within the pattern, or by setting an
      option when a compiled pattern is matched.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_CASELESS
</pre>
      </div>

      <p>If this bit is set, letters in the pattern match both
      upper and lower case letters. It is equivalent to Perl's /i
      option, and it can be changed within a pattern by a (?i)
      option setting. In UTF-8 mode, PCRE always understands the
      concept of case for characters whose values are less than
      128, so caseless matching is always possible. For characters
      with higher values, the concept of case is supported if PCRE
      is compiled with Unicode property support, but not otherwise.
      If you want to use caseless matching for characters 128 and
      above, you must ensure that PCRE is compiled with Unicode
      property support as well as with UTF-8 support.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_DOLLAR_ENDONLY
</pre>
      </div>

      <p>If this bit is set, a dollar metacharacter in the pattern
      matches only at the end of the subject string. Without this
      option, a dollar also matches immediately before a newline at
      the end of the string (but not before any other newlines).
      The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE
      is set. There is no equivalent to this option in Perl, and no
      way to set it within a pattern.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_DOTALL
</pre>
      </div>

      <p>If this bit is set, a dot metacharacter in the pattern
      matches a character of any value, including one that
      indicates a newline. However, it only ever matches one
      character, even if newlines are coded as CRLF. Without this
      option, a dot does not match when the current position is at
      a newline. This option is equivalent to Perl's /s option, and
      it can be changed within a pattern by a (?s) option setting.
      A negative class such as [^a] always matches newline
      characters, independent of the setting of this option.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_DUPNAMES
</pre>
      </div>

      <p>If this bit is set, names used to identify capturing
      subpatterns need not be unique. This can be helpful for
      certain types of pattern when it is known that only one
      instance of the named subpattern can ever be matched. There
      are more details of named subpatterns below; see also the
      <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_EXTENDED
</pre>
      </div>

      <p>If this bit is set, most white space characters in the
      pattern are totally ignored except when escaped or inside a
      character class. However, white space is not allowed within
      sequences such as (?&gt; that introduce various parenthesized
      subpatterns, nor within a numerical quantifier such as {1,3}.
      However, ignorable white space is permitted between an item
      and a following quantifier and between a quantifier and a
      following + that indicates possessiveness.</p>

      <p>White space did not used to include the VT character (code
      11), because Perl did not treat this character as white
      space. However, Perl changed at release 5.18, so PCRE
      followed at release 8.34, and VT is now treated as white
      space.</p>

      <p>PCRE_EXTENDED also causes characters between an unescaped
      # outside a character class and the next newline, inclusive,
      to be ignored. PCRE_EXTENDED is equivalent to Perl's /x
      option, and it can be changed within a pattern by a (?x)
      option setting.</p>

      <p>Which characters are interpreted as newlines is controlled
      by the options passed to <code class="function">pcre_compile</code>() or by a special sequence at
      the start of the pattern, as described in the section
      entitled "Newline conventions" in the <code class="function">pcrepattern</code> documentation. Note that the
      end of this type of comment is a literal newline sequence in
      the pattern; escape sequences that happen to represent a
      newline do not count.</p>

      <p>This option makes it possible to include comments inside
      complicated patterns. Note, however, that this applies only
      to data characters. White space characters may never appear
      within special character sequences in a pattern, for example
      within the sequence (?( that introduces a conditional
      subpattern.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_EXTRA
</pre>
      </div>

      <p>This option was invented in order to turn on additional
      functionality of PCRE that is incompatible with Perl, but it
      is currently of very little use. When set, any backslash in a
      pattern that is followed by a letter that has no special
      meaning causes an error, thus reserving these combinations
      for future expansion. By default, as in Perl, a backslash
      followed by a letter with no special meaning is treated as a
      literal. (Perl can, however, be persuaded to give an error
      for this, by running it with the -w option.) There are at
      present no other features controlled by this option. It can
      also be set by a (?X) option setting within a pattern.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_FIRSTLINE
</pre>
      </div>

      <p>If this option is set, an unanchored pattern is required
      to match before or at the first newline in the subject
      string, though the matched text may continue over the
      newline.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_JAVASCRIPT_COMPAT
</pre>
      </div>

      <p>If this option is set, PCRE's behaviour is changed in some
      ways so that it is compatible with JavaScript rather than
      Perl. The changes are as follows:</p>

      <p>(1) A lone closing square bracket in a pattern causes a
      compile-time error, because this is illegal in JavaScript (by
      default it is treated as a data character). Thus, the pattern
      AB]CD becomes illegal when this option is set.</p>

      <p>(2) At run time, a back reference to an unset subpattern
      group matches an empty string (by default this causes the
      current matching alternative to fail). A pattern such as
      (\1)(a) succeeds when this option is set (assuming it can
      find an "a" in the subject), whereas it fails by default, for
      Perl compatibility.</p>

      <p>(3) \U matches an upper case "U" character; by default \U
      causes a compile time error (Perl uses \U to upper case
      subsequent characters).</p>

      <p>(4) \u matches a lower case "u" character unless it is
      followed by four hexadecimal digits, in which case the
      hexadecimal number defines the code point to match. By
      default, \u causes a compile time error (Perl uses it to
      upper case the following character).</p>

      <p>(5) \x matches a lower case "x" character unless it is
      followed by two hexadecimal digits, in which case the
      hexadecimal number defines the code point to match. By
      default, as in Perl, a hexadecimal number is always expected
      after \x, but it may have zero, one, or two digits (so, for
      example, \xz matches a binary zero character followed by
      z).</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_MULTILINE
</pre>
      </div>

      <p>By default, for the purposes of matching "start of line"
      and "end of line", PCRE treats the subject string as
      consisting of a single line of characters, even if it
      actually contains newlines. The "start of line" metacharacter
      (^) matches only at the start of the string, and the "end of
      line" metacharacter ($) matches only at the end of the
      string, or before a terminating newline (except when
      PCRE_DOLLAR_ENDONLY is set). Note, however, that unless
      PCRE_DOTALL is set, the "any character" metacharacter (.)
      does not match at a newline. This behaviour (for ^, $, and
      dot) is the same as Perl.</p>

      <p>When PCRE_MULTILINE it is set, the "start of line" and
      "end of line" constructs match immediately following or
      immediately before internal newlines in the subject string,
      respectively, as well as at the very start and end. This is
      equivalent to Perl's /m option, and it can be changed within
      a pattern by a (?m) option setting. If there are no newlines
      in a subject string, or no occurrences of ^ or $ in a
      pattern, setting PCRE_MULTILINE has no effect.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_NEVER_UTF
</pre>
      </div>

      <p>This option locks out interpretation of the pattern as
      UTF-8 (or UTF-16 or UTF-32 in the 16-bit and 32-bit
      libraries). In particular, it prevents the creator of the
      pattern from switching to UTF interpretation by starting the
      pattern with (*UTF). This may be useful in applications that
      process patterns from external sources. The combination of
      PCRE_UTF8 and PCRE_NEVER_UTF also causes an error.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_NEWLINE_CR
 PCRE_NEWLINE_LF
 PCRE_NEWLINE_CRLF
 PCRE_NEWLINE_ANYCRLF
 PCRE_NEWLINE_ANY
</pre>
      </div>

      <p>These options override the default newline definition that
      was chosen when PCRE was built. Setting the first or the
      second specifies that a newline is indicated by a single
      character (CR or LF, respectively). Setting PCRE_NEWLINE_CRLF
      specifies that a newline is indicated by the two-character
      CRLF sequence. Setting PCRE_NEWLINE_ANYCRLF specifies that
      any of the three preceding sequences should be recognized.
      Setting PCRE_NEWLINE_ANY specifies that any Unicode newline
      sequence should be recognized.</p>

      <p>In an ASCII/Unicode environment, the Unicode newline
      sequences are the three just mentioned, plus the single
      characters VT (vertical tab, U+000B), FF (form feed, U+000C),
      NEL (next line, U+0085), LS (line separator, U+2028), and PS
      (paragraph separator, U+2029). For the 8-bit library, the
      last two are recognized only in UTF-8 mode.</p>

      <p>When PCRE is compiled to run in an EBCDIC (mainframe)
      environment, the code for CR is 0x0d, the same as ASCII.
      However, the character code for LF is normally 0x15, though
      in some EBCDIC environments 0x25 is used. Whichever of these
      is not LF is made to correspond to Unicode's NEL character.
      EBCDIC codes are all less than 256. For more details, see the
      <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a>
      documentation.</p>

      <p>The newline setting in the options word uses three bits
      that are treated as a number, giving eight possibilities.
      Currently only six are used (default plus the five values
      above). This means that if you set more than one newline
      option, the combination may or may not be sensible. For
      example, PCRE_NEWLINE_CR with PCRE_NEWLINE_LF is equivalent
      to PCRE_NEWLINE_CRLF, but other combinations may yield unused
      numbers and cause an error.</p>

      <p>The only time that a line break in a pattern is specially
      recognized when compiling is when PCRE_EXTENDED is set. CR
      and LF are white space characters, and so are ignored in this
      mode. Also, an unescaped # outside a character class
      indicates a comment that lasts until after the next line
      break sequence. In other circumstances, line break sequences
      in patterns are treated as literal data.</p>

      <p>The newline option that is set at compile time becomes the
      default that is used for <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(), but it can be
      overridden.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_NO_AUTO_CAPTURE
</pre>
      </div>

      <p>If this option is set, it disables the use of numbered
      capturing parentheses in the pattern. Any opening parenthesis
      that is not followed by ? behaves as if it were followed by
      ?: but named parentheses can still be used for capturing (and
      they acquire numbers in the usual way). There is no
      equivalent of this option in Perl.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_NO_AUTO_POSSESS
</pre>
      </div>

      <p>If this option is set, it disables
      "auto-possessification". This is an optimization that, for
      example, turns a+b into a++b in order to avoid backtracks
      into a+ that can never be successful. However, if callouts
      are in use, auto-possessification means that some of them are
      never taken. You can set this option if you want the matching
      functions to do a full unoptimized search and run all the
      callouts, but it is mainly provided for testing purposes.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_NO_START_OPTIMIZE
</pre>
      </div>

      <p>This is an option that acts at matching time; that is, it
      is really an option for <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). If it is set at compile
      time, it is remembered with the compiled pattern and assumed
      at matching time. This is necessary if you want to use JIT
      execution, because the JIT compiler needs to know whether or
      not this option is set. For details see the discussion of
      PCRE_NO_START_OPTIMIZE below.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_UCP
</pre>
      </div>

      <p>This option changes the way PCRE processes \B, \b, \D, \d,
      \S, \s, \W, \w, and some of the POSIX character classes. By
      default, only ASCII characters are recognized, but if
      PCRE_UCP is set, Unicode properties are used instead to
      classify characters. More details are given in the section on
      generic character types in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page. If you
      set PCRE_UCP, matching one of the items it affects takes much
      longer. The option is available only if PCRE has been
      compiled with Unicode property support.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_UNGREEDY
</pre>
      </div>

      <p>This option inverts the "greediness" of the quantifiers so
      that they are not greedy by default, but become greedy if
      followed by "?". It is not compatible with Perl. It can also
      be set by a (?U) option setting within the pattern.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_UTF8
</pre>
      </div>

      <p>This option causes PCRE to regard both the pattern and the
      subject as strings of UTF-8 characters instead of single-byte
      strings. However, it is available only when PCRE is built to
      include UTF support. If not, the use of this option provokes
      an error. Details of how this option changes the behaviour of
      PCRE are given in the <a class="link" href="../htmlman3/pcreunicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreunicode</span>(3)</span></a> page.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_NO_UTF8_CHECK
</pre>
      </div>

      <p>When PCRE_UTF8 is set, the validity of the pattern as a
      UTF-8 string is automatically checked. There is a discussion
      about the validity of UTF-8 strings in the <a class="link" href="../htmlman3/pcreunicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreunicode</span>(3)</span></a> page. If an
      invalid UTF-8 sequence is found, <code class="function">pcre_compile</code>() returns an error. If you
      already know that your pattern is valid, and you want to skip
      this check for performance reasons, you can set the
      PCRE_NO_UTF8_CHECK option. When it is set, the effect of
      passing an invalid UTF-8 string as a pattern is undefined. It
      may cause your program to crash or loop. Note that this
      option can also be passed to <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(), to suppress the validity
      checking of subject strings only. If the same string is being
      matched many times, the option can be safely set for the
      second and subsequent matchings to improve performance.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect8" name="pcreapi-3_sect8" shape="rect"> </a>

      <h2>COMPILATION ERROR CODES</h2>

      <p>The following table lists the error codes than may be
      returned by <code class="function">pcre_compile2</code>(),
      along with the error messages that may be returned by both
      compiling functions. Note that error messages are always
      8-bit ASCII strings, even in 16-bit or 32-bit mode. As PCRE
      has developed, some error codes have fallen out of use. To
      avoid confusion, they have not been re-used.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
  0  no error
  1  \ at end of pattern
  2  \c at end of pattern
  3  unrecognized character follows \
  4  numbers out of order in {} quantifier
  5  number too big in {} quantifier
  6  missing terminating ] for character class
  7  invalid escape sequence in character class
  8  range out of order in character class
  9  nothing to repeat
 10  [this code is not in use]
 11  internal error: unexpected repeat
 12  unrecognized character after (? or (?-
 13  POSIX named classes are supported only within a class
 14  missing )
 15  reference to non-existent subpattern
 16  erroffset passed as NULL
 17  unknown option bit(s) set
 18  missing ) after comment
 19  [this code is not in use]
 20  regular expression is too large
 21  failed to get memory
 22  unmatched parentheses
 23  internal error: code overflow
 24  unrecognized character after (?&lt;
 25  lookbehind assertion is not fixed length
 26  malformed number or name after (?(
 27  conditional group contains more than two branches
 28  assertion expected after (?(
 29  (?R or (?[+-]digits must be followed by )
 30  unknown POSIX class name
 31  POSIX collating elements are not supported
 32  this version of PCRE is compiled without UTF support
 33  [this code is not in use]
 34  character value in \x{} or \o{} is too large
 35  invalid condition (?(0)
 36  \C not allowed in lookbehind assertion
 37  PCRE does not support \L, \l, \N{name}, \U, or \u
 38  number after (?C is &gt; 255
 39  closing ) for (?C expected
 40  recursive call could loop indefinitely
 41  unrecognized character after (?P
 42  syntax error in subpattern name (missing terminator)
 43  two named subpatterns have the same name
 44  invalid UTF-8 string (specifically UTF-8)
 45  support for \P, \p, and \X has not been compiled
 46  malformed \P or \p sequence
 47  unknown property name after \P or \p
 48  subpattern name is too long (maximum 32 characters)
 49  too many named subpatterns (maximum 10000)
 50  [this code is not in use]
 51  octal value is greater than \377 in 8-bit non-UTF-8 mode
 52  internal error: overran compiling workspace
 53  internal error: previously-checked referenced subpattern
       not found
 54  DEFINE group contains more than one branch
 55  repeating a DEFINE group is not allowed
 56  inconsistent NEWLINE options
 57  \g is not followed by a braced, angle-bracketed, or quoted
       name/number or by a plain number
 58  a numbered reference must not be zero
 59  an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)
 60  (*VERB) not recognized or malformed
 61  number is too big
 62  subpattern name expected
 63  digit expected after (?+
 64  ] is an invalid data character in JavaScript compatibility mode
 65  different names for subpatterns of the same number are
       not allowed
 66  (*MARK) must have an argument
 67  this version of PCRE is not compiled with Unicode property
       support
 68  \c must be followed by an ASCII character
 69  \k is not followed by a braced, angle-bracketed, or quoted name
 70  internal error: unknown opcode in find_fixedlength()
 71  \N is not supported in a class
 72  too many forward references
 73  disallowed Unicode code point (&gt;= 0xd800 &amp;&amp; &lt;= 0xdfff)
 74  invalid UTF-16 string (specifically UTF-16)
 75  name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)
 76  character value in \u.... sequence is too large
 77  invalid UTF-32 string (specifically UTF-32)
 78  setting UTF is disabled by the application
 79  non-hex character in \x{} (closing brace missing?)
 80  non-octal character in \o{} (closing brace missing?)
 81  missing opening brace after \o
 82  parentheses are too deeply nested
 83  invalid range in character class
 84  group name must start with a non-digit
 85  parentheses are too deeply nested (stack check)
</pre>
      </div>

      <p>The numbers 32 and 10000 in errors 48 and 49 are defaults;
      different values may be used if the limits were changed when
      PCRE was built.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect9" name="pcreapi-3_sect9" shape="rect"> </a>

      <h2>STUDYING A PATTERN</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre_extra *pcre_study(const pcre *<em class="parameter"><code>code</code></em>, int <em class="parameter"><code>options</code></em>,</em></span>
<span class="emphasis"><em>     const char **<em class="parameter"><code>errptr</code></em>);</em></span>
</pre>
      </div>

      <p>If a compiled pattern is going to be used several times,
      it is worth spending more time analyzing it in order to speed
      up the time taken for matching. The function <code class="function">pcre_study</code>() takes a pointer to a compiled
      pattern as its first argument. If studying the pattern
      produces additional information that will help speed up
      matching, <code class="function">pcre_study</code>() returns
      a pointer to a <code class="function">pcre_extra</code>
      block, in which the <code class="function">study_data</code>
      field points to the results of the study.</p>

      <p>The returned value from <code class="function">pcre_study</code>() can be passed directly to
      <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). However, a <code class="function">pcre_extra</code> block also contains other fields
      that can be set by the caller before the block is passed;
      these are described below in the section on matching a
      pattern.</p>

      <p>If studying the pattern does not produce any useful
      information, <code class="function">pcre_study</code>()
      returns NULL by default. In that circumstance, if the calling
      program wants to pass any of the other fields to <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(), it must set up its own
      <code class="function">pcre_extra</code> block. However, if
      <code class="function">pcre_study</code>() is called with the
      PCRE_STUDY_EXTRA_NEEDED option, it returns a <code class="function">pcre_extra</code> block even if studying did not
      find any additional information. It may still return NULL,
      however, if an error occurs in <code class="function">pcre_study</code>().</p>

      <p>The second argument of <code class="function">pcre_study</code>() contains option bits. There
      are three further options in addition to
      PCRE_STUDY_EXTRA_NEEDED:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_STUDY_JIT_COMPILE
 PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
 PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
</pre>
      </div>

      <p>If any of these are set, and the just-in-time compiler is
      available, the pattern is further compiled into machine code
      that executes much faster than the <code class="function">pcre_exec</code>() interpretive matching function.
      If the just-in-time compiler is not available, these options
      are ignored. All undefined bits in the <em class="parameter"><code>options</code></em> argument must be
      zero.</p>

      <p>JIT compilation is a heavyweight optimization. It can take
      some time for patterns to be analyzed, and for one-off
      matches and simple patterns the benefit of faster execution
      might be offset by a much slower study time. Not all patterns
      can be optimized by the JIT compiler. For those that cannot
      be handled, matching automatically falls back to the
      <code class="function">pcre_exec</code>() interpreter. For
      more details, see the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a>
      documentation.</p>

      <p>The third argument for <code class="function">pcre_study</code>() is a pointer for an error
      message. If studying succeeds (even if no data is returned),
      the variable it points to is set to NULL. Otherwise it is set
      to point to a textual error message. This is a static string
      that is part of the library. You must not try to free it. You
      should test the error pointer for NULL after calling
      <code class="function">pcre_study</code>(), to be sure that
      it has run successfully.</p>

      <p>When you are finished with a pattern, you can free the
      memory used for the study data by calling <code class="function">pcre_free_study</code>(). This function was added
      to the API for release 8.20. For earlier versions, the memory
      could be freed with <code class="function">pcre_free</code>(), just like the pattern itself.
      This will still work in cases where JIT optimization is not
      used, but it is advisable to change to the new function when
      convenient.</p>

      <p>This is a typical way in which <code class="function">pcre_study</code>() is used (except that in a real
      application there should be tests for errors):</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 pcre *re;
 pcre_extra *sd;
 re = pcre_compile("pattern", 0, &amp;error, &amp;erroroffset, NULL);
 sd = pcre_study(
   re,             /* result of pcre_compile() */
   0,              /* no options */
   &amp;error);        /* set to NULL or points to a message */
 rc = pcre_exec(   /* see below for details of pcre_exec() options */
   re, sd, "subject", 7, 0, 0, ovector, 30);
 ...
 pcre_free_study(sd);
 pcre_free(re);
</pre>
      </div>

      <p>Studying a pattern does two things: first, a lower bound
      for the length of subject string that is needed to match the
      pattern is computed. This does not mean that there are any
      strings of that length that match, but it does guarantee that
      no shorter strings match. The value is used to avoid wasting
      time by trying to match strings that are shorter than the
      lower bound. You can find out the value in a calling program
      via the <code class="function">pcre_fullinfo</code>()
      function.</p>

      <p>Studying a pattern is also useful for non-anchored
      patterns that do not have a single fixed starting character.
      A bitmap of possible starting bytes is created. This speeds
      up finding a position in the subject at which to start
      matching. (In 16-bit mode, the bitmap is used for 16-bit
      values less than 256. In 32-bit mode, the bitmap is used for
      32-bit values less than 256.)</p>

      <p>These two optimizations apply to both <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(), and the information is
      also used by the JIT compiler. The optimizations can be
      disabled by setting the PCRE_NO_START_OPTIMIZE option. You
      might want to do this if your pattern contains callouts or
      (*MARK) and you want to make use of these facilities in cases
      where matching fails.</p>

      <p>PCRE_NO_START_OPTIMIZE can be specified at either compile
      time or execution time. However, if PCRE_NO_START_OPTIMIZE is
      passed to <code class="function">pcre_exec</code>(), (that
      is, after any JIT compilation has happened) JIT execution is
      disabled. For JIT execution to work with
      PCRE_NO_START_OPTIMIZE, the option must be set at compile
      time.</p>

      <p>There is a longer discussion of PCRE_NO_START_OPTIMIZE
      below.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect10" name="pcreapi-3_sect10" shape="rect"> </a>

      <h2>LOCALE SUPPORT</h2>

      <p>PCRE handles caseless matching, and determines whether
      characters are letters, digits, or whatever, by reference to
      a set of tables, indexed by character code point. When
      running in UTF-8 mode, or in the 16- or 32-bit libraries,
      this applies only to characters with code points less than
      256. By default, higher-valued code points never match
      escapes such as \w or \d. However, if PCRE is built with
      Unicode property support, all characters can be tested with
      \p and \P, or, alternatively, the PCRE_UCP option can be set
      when a pattern is compiled; this causes \w and friends to use
      Unicode property support instead of the built-in tables.</p>

      <p>The use of locales with Unicode is discouraged. If you are
      handling characters with code points greater than 128, you
      should either use Unicode support, or use locales, but not
      try to mix the two.</p>

      <p>PCRE contains an internal set of tables that are used when
      the final argument of <code class="function">pcre_compile</code>() is NULL. These are
      sufficient for many applications. Normally, the internal
      tables recognize only ASCII characters. However, when PCRE is
      built, it is possible to cause the internal tables to be
      rebuilt in the default "C" locale of the local system, which
      may cause them to be different.</p>

      <p>The internal tables can always be overridden by tables
      supplied by the application that calls PCRE. These may be
      created in a different locale from the default. As more and
      more applications change to using Unicode, the need for this
      locale support is expected to die away.</p>

      <p>External tables are built by calling the <code class="function">pcre_maketables</code>() function, which has no
      arguments, in the relevant locale. The result can then be
      passed to <code class="function">pcre_compile</code>() as
      often as necessary. For example, to build and use tables that
      are appropriate for the French locale (where accented
      characters with values greater than 128 are treated as
      letters), the following code could be used:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 setlocale(LC_CTYPE, "fr_FR");
 tables = pcre_maketables();
 re = pcre_compile(..., tables);
</pre>
      </div>

      <p>The locale name "fr_FR" is used on Linux and other
      Unix-like systems; if you are using Windows, the name for the
      French locale is "french".</p>

      <p>When <code class="function">pcre_maketables</code>() runs,
      the tables are built in memory that is obtained via
      <code class="function">pcre_malloc</code>. It is the caller's
      responsibility to ensure that the memory containing the
      tables remains available for as long as it is needed.</p>

      <p>The pointer that is passed to <code class="function">pcre_compile</code>() is saved with the compiled
      pattern, and the same tables are used via this pointer by
      <code class="function">pcre_study</code>() and also by
      <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(). Thus, for any single
      pattern, compilation, studying and matching all happen in the
      same locale, but different patterns can be processed in
      different locales.</p>

      <p>It is possible to pass a table pointer or NULL (indicating
      the use of the internal tables) to <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>() (see the discussion below
      in the section on matching a pattern). This facility is
      provided for use with pre-compiled patterns that have been
      saved and reloaded. Character tables are not saved with
      patterns, so if a non-standard table was used at compile
      time, it must be provided again when the reloaded pattern is
      matched. Attempting to use this facility to match a pattern
      in a different locale from the one in which it was compiled
      is likely to lead to anomalous (usually incorrect)
      results.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect11" name="pcreapi-3_sect11" shape="rect"> </a>

      <h2>INFORMATION ABOUT A PATTERN</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre_fullinfo(const pcre *<em class="parameter"><code>code</code></em>, const pcre_extra *<em class="parameter"><code>extra</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>what</code></em>, void *<em class="parameter"><code>where</code></em>);</em></span>
</pre>
      </div>

      <p>The <code class="function">pcre_fullinfo</code>() function
      returns information about a compiled pattern. It replaces the
      <code class="function">pcre_info</code>() function, which was
      removed from the library at version 8.30, after more than 10
      years of obsolescence.</p>

      <p>The first argument for <code class="function">pcre_fullinfo</code>() is a pointer to the
      compiled pattern. The second argument is the result of
      <code class="function">pcre_study</code>(), or NULL if the
      pattern was not studied. The third argument specifies which
      piece of information is required, and the fourth argument is
      a pointer to a variable to receive the data. The yield of the
      function is zero for success, or one of the following
      negative numbers:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_ERROR_NULL           the argument <em class="parameter"><code>code</code></em> was NULL
                           the argument <em class="parameter"><code>where</code></em> was NULL
 PCRE_ERROR_BADMAGIC       the "magic number" was not found
 PCRE_ERROR_BADENDIANNESS  the pattern was compiled with different
                           endianness
 PCRE_ERROR_BADOPTION      the value of <em class="parameter"><code>what</code></em> was invalid
 PCRE_ERROR_UNSET          the requested field is not set
</pre>
      </div>

      <p>The "magic number" is placed at the start of each compiled
      pattern as an simple check against passing an arbitrary
      memory pointer. The endianness error can occur if a compiled
      pattern is saved and reloaded on a different host. Here is a
      typical call of <code class="function">pcre_fullinfo</code>(), to obtain the length of
      the compiled pattern:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 size_t length;
 rc = pcre_fullinfo(
   re,               /* result of pcre_compile() */
   sd,               /* result of pcre_study(), or NULL */
   PCRE_INFO_SIZE,   /* what is required */
   &amp;length);         /* where to put the data */
</pre>
      </div>

      <p>The possible values for the third argument are defined in
      <code class="filename">pcre.h</code>, and are as follows:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_BACKREFMAX
</pre>
      </div>

      <p>Return the number of the highest back reference in the
      pattern. The fourth argument should point to an <span class="type">int</span> variable. Zero is returned if there are no
      back references.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_CAPTURECOUNT
</pre>
      </div>

      <p>Return the number of capturing subpatterns in the pattern.
      The fourth argument should point to an <span class="type">int</span> variable.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_DEFAULT_TABLES
</pre>
      </div>

      <p>Return a pointer to the internal default character tables
      within PCRE. The fourth argument should point to an
      <span class="type">unsigned char *</span> variable. This
      information call is provided for internal use by the
      <code class="function">pcre_study</code>() function. External
      callers can cause PCRE to use its internal tables by passing
      a NULL table pointer.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_FIRSTBYTE (deprecated)
</pre>
      </div>

      <p>Return information about the first data unit of any
      matched string, for a non-anchored pattern. The name of this
      option refers to the 8-bit library, where data units are
      bytes. The fourth argument should point to an <span class="type">int</span> variable. Negative values are used for
      special cases. However, this means that when the 32-bit
      library is in non-UTF-32 mode, the full 32-bit range of
      characters cannot be returned. For this reason, this value is
      deprecated; use PCRE_INFO_FIRSTCHARACTERFLAGS and
      PCRE_INFO_FIRSTCHARACTER instead.</p>

      <p>If there is a fixed first value, for example, the letter
      "c" from a pattern such as (cat|cow|coyote), its value is
      returned. In the 8-bit library, the value is always less than
      256. In the 16-bit library the value can be up to 0xffff. In
      the 32-bit library the value can be up to 0x10ffff.</p>

      <p>If there is no fixed first value, and if either</p>

      <p>(a) the pattern was compiled with the PCRE_MULTILINE
      option, and every branch starts with "^", or</p>

      <p>(b) every branch of the pattern starts with ".*" and
      PCRE_DOTALL is not set (if it were set, the pattern would be
      anchored),</p>

      <p>-1 is returned, indicating that the pattern matches only
      at the start of a subject string or after any newline within
      the string. Otherwise -2 is returned. For anchored patterns,
      -2 is returned.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_FIRSTCHARACTER
</pre>
      </div>

      <p>Return the value of the first data unit (non-UTF
      character) of any matched string in the situation where
      PCRE_INFO_FIRSTCHARACTERFLAGS returns 1; otherwise return 0.
      The fourth argument should point to an <span class="type">uint_t</span> variable.</p>

      <p>In the 8-bit library, the value is always less than 256.
      In the 16-bit library the value can be up to 0xffff. In the
      32-bit library in UTF-32 mode the value can be up to
      0x10ffff, and up to 0xffffffff when not using UTF-32
      mode.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_FIRSTCHARACTERFLAGS
</pre>
      </div>

      <p>Return information about the first data unit of any
      matched string, for a non-anchored pattern. The fourth
      argument should point to an <span class="type">int</span>
      variable.</p>

      <p>If there is a fixed first value, for example, the letter
      "c" from a pattern such as (cat|cow|coyote), 1 is returned,
      and the character value can be retrieved using
      PCRE_INFO_FIRSTCHARACTER. If there is no fixed first value,
      and if either</p>

      <p>(a) the pattern was compiled with the PCRE_MULTILINE
      option, and every branch starts with "^", or</p>

      <p>(b) every branch of the pattern starts with ".*" and
      PCRE_DOTALL is not set (if it were set, the pattern would be
      anchored),</p>

      <p>2 is returned, indicating that the pattern matches only at
      the start of a subject string or after any newline within the
      string. Otherwise 0 is returned. For anchored patterns, 0 is
      returned.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_FIRSTTABLE
</pre>
      </div>

      <p>If the pattern was studied, and this resulted in the
      construction of a 256-bit table indicating a fixed set of
      values for the first data unit in any matching string, a
      pointer to the table is returned. Otherwise NULL is returned.
      The fourth argument should point to an <span class="type">unsigned char *</span> variable.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_HASCRORLF
</pre>
      </div>

      <p>Return 1 if the pattern contains any explicit matches for
      CR or LF characters, otherwise 0. The fourth argument should
      point to an <span class="type">int</span> variable. An
      explicit match is either a literal CR or LF character, or \r
      or \n.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_JCHANGED
</pre>
      </div>

      <p>Return 1 if the (?J) or (?-J) option setting is used in
      the pattern, otherwise 0. The fourth argument should point to
      an <span class="type">int</span> variable. (?J) and (?-J) set
      and unset the local PCRE_DUPNAMES option, respectively.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_JIT
</pre>
      </div>

      <p>Return 1 if the pattern was studied with one of the JIT
      options, and just-in-time compiling was successful. The
      fourth argument should point to an <span class="type">int</span> variable. A return value of 0 means that
      JIT support is not available in this version of PCRE, or that
      the pattern was not studied with a JIT option, or that the
      JIT compiler could not handle this particular pattern. See
      the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a> documentation
      for details of what can and cannot be handled.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_JITSIZE
</pre>
      </div>

      <p>If the pattern was successfully studied with a JIT option,
      return the size of the JIT compiled code, otherwise return
      zero. The fourth argument should point to a <em class="parameter"><code>size_t</code></em> variable.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_LASTLITERAL
</pre>
      </div>

      <p>Return the value of the rightmost literal data unit that
      must exist in any matched string, other than at its start, if
      such a value has been recorded. The fourth argument should
      point to an <span class="type">int</span> variable. If there
      is no such value, -1 is returned. For anchored patterns, a
      last literal value is recorded only if it follows something
      of variable length. For example, for the pattern /^a\d+z\d+/
      the returned value is "z", but for /^a\dz\d/ the returned
      value is -1.</p>

      <p>Since for the 32-bit library using the non-UTF-32 mode,
      this function is unable to return the full 32-bit range of
      characters, this value is deprecated; instead the
      PCRE_INFO_REQUIREDCHARFLAGS and PCRE_INFO_REQUIREDCHAR values
      should be used.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_MATCH_EMPTY
</pre>
      </div>

      <p>Return 1 if the pattern can match an empty string,
      otherwise 0. The fourth argument should point to an
      <span class="type">int</span> variable.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_MATCHLIMIT
</pre>
      </div>

      <p>If the pattern set a match limit by including an item of
      the form (*LIMIT_MATCH=nnnn) at the start, the value is
      returned. The fourth argument should point to an unsigned
      32-bit integer. If no such value has been set, the call to
      <code class="function">pcre_fullinfo</code>() returns the
      error PCRE_ERROR_UNSET.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_MAXLOOKBEHIND
</pre>
      </div>

      <p>Return the number of characters (NB not data units) in the
      longest lookbehind assertion in the pattern. This information
      is useful when doing multi-segment matching using the partial
      matching facilities. Note that the simple assertions \b and
      \B require a one-character lookbehind. \A also registers a
      one-character lookbehind, though it does not actually inspect
      the previous character. This is to ensure that at least one
      character from the old segment is retained when a new segment
      is processed. Otherwise, if there are no lookbehinds in the
      pattern, \A might match incorrectly at the start of a new
      segment.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_MINLENGTH
</pre>
      </div>

      <p>If the pattern was studied and a minimum length for
      matching subject strings was computed, its value is returned.
      Otherwise the returned value is -1. The value is a number of
      characters, which in UTF mode may be different from the
      number of data units. The fourth argument should point to an
      <span class="type">int</span> variable. A non-negative value
      is a lower bound to the length of any matching string. There
      may not be any strings of that length that do actually match,
      but every string that does match is at least that long.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_INFO_NAMECOUNT
 PCRE_INFO_NAMEENTRYSIZE
 PCRE_INFO_NAMETABLE
</pre>
      </div>

      <p>PCRE supports the use of named as well as numbered
      capturing parentheses. The names are just an additional way
      of identifying the parentheses, which still acquire numbers.
      Several convenience functions such as <code class="function">pcre_get_named_substring</code>() are provided for
      extracting captured substrings by name. It is also possible
      to extract the data directly, by first converting the name to
      a number in order to access the correct pointers in the
      output vector (described with <code class="function">pcre_exec</code>() below). To do the conversion,
      you need to use the name-to-number map, which is described by
      these three values.</p>

      <p>The map consists of a number of fixed-size entries.
      PCRE_INFO_NAMECOUNT gives the number of entries, and
      PCRE_INFO_NAMEENTRYSIZE gives the size of each entry; both of
      these return an <span class="type">int</span> value. The
      entry size depends on the length of the longest name.
      PCRE_INFO_NAMETABLE returns a pointer to the first entry of
      the table. This is a pointer to <span class="type">char</span> in the 8-bit library, where the first two
      bytes of each entry are the number of the capturing
      parenthesis, most significant byte first. In the 16-bit
      library, the pointer points to 16-bit data units, the first
      of which contains the parenthesis number. In the 32-bit
      library, the pointer points to 32-bit data units, the first
      of which contains the parenthesis number. The rest of the
      entry is the corresponding name, zero terminated.</p>

      <p>The names are in alphabetical order. If (?| is used to
      create multiple groups with the same number, as described in
      the section on duplicate subpattern numbers in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page, the
      groups may be given the same name, but there is only one
      entry in the table. Different names for groups of the same
      number are not permitted. Duplicate names for subpatterns
      with different numbers are permitted, but only if
      PCRE_DUPNAMES is set. They appear in the table in the order
      in which they were found in the pattern. In the absence of
      (?| this is the order of increasing number; when (?| is used
      this is not necessarily the case because later subpatterns
      may have lower numbers.</p>

      <p>As a simple example of the name/number table, consider the
      following pattern after compilation by the 8-bit library
      (assume PCRE_EXTENDED is set, so white space - including
      newlines - is ignored):</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 (?&lt;date&gt; (?&lt;year&gt;(\d\d)?\d\d) -
 (?&lt;month&gt;\d\d) - (?&lt;day&gt;\d\d) )
</pre>
      </div>

      <p>There are four named subpatterns, so the table has four
      entries, and each entry in the table is eight bytes long. The
      table is as follows, with non-printing bytes shows in
      hexadecimal, and undefined bytes shown as ??:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 00 01 d  a  t  e  00 ??
 00 05 d  a  y  00 ?? ??
 00 04 m  o  n  t  h  00
 00 02 y  e  a  r  00 ??
</pre>
      </div>

      <p>When writing code to extract data from named subpatterns
      using the name-to-number map, remember that the length of the
      entries is likely to be different for each compiled
      pattern.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_OKPARTIAL
</pre>
      </div>

      <p>Return 1 if the pattern can be used for partial matching
      with <code class="function">pcre_exec</code>(), otherwise 0.
      The fourth argument should point to an <span class="type">int</span> variable. From release 8.00, this always
      returns 1, because the restrictions that previously applied
      to partial matching have been lifted. The <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
      documentation gives details of partial matching.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_OPTIONS
</pre>
      </div>

      <p>Return a copy of the options with which the pattern was
      compiled. The fourth argument should point to an <span class="type">unsigned long int</span> variable. These option bits
      are those specified in the call to <code class="function">pcre_compile</code>(), modified by any top-level
      option settings at the start of the pattern itself. In other
      words, they are the options that will be in force when
      matching starts. For example, if the pattern /(?im)abc(?-i)d/
      is compiled with the PCRE_EXTENDED option, the result is
      PCRE_CASELESS, PCRE_MULTILINE, and PCRE_EXTENDED.</p>

      <p>A pattern is automatically anchored by PCRE if all of its
      top-level alternatives begin with one of the following:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 ^     unless PCRE_MULTILINE is set
 \A    always
 \G    always
 .*    if PCRE_DOTALL is set and there are no back
         references to the subpattern in which .* appears
</pre>
      </div>

      <p>For such patterns, the PCRE_ANCHORED bit is set in the
      options returned by <code class="function">pcre_fullinfo</code>().</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_RECURSIONLIMIT
</pre>
      </div>

      <p>If the pattern set a recursion limit by including an item
      of the form (*LIMIT_RECURSION=nnnn) at the start, the value
      is returned. The fourth argument should point to an unsigned
      32-bit integer. If no such value has been set, the call to
      <code class="function">pcre_fullinfo</code>() returns the
      error PCRE_ERROR_UNSET.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_SIZE
</pre>
      </div>

      <p>Return the size of the compiled pattern in bytes (for all
      three libraries). The fourth argument should point to a
      <em class="parameter"><code>size_t</code></em> variable. This
      value does not include the size of the <code class="function">pcre</code> structure that is returned by
      <code class="function">pcre_compile</code>(). The value that
      is passed as the argument to <code class="function">pcre_malloc</code>() when <code class="function">pcre_compile</code>() is getting memory in which
      to place the compiled data is the value returned by this
      option plus the size of the <code class="function">pcre</code> structure. Studying a compiled
      pattern, with or without JIT, does not alter the value
      returned by this option.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_STUDYSIZE
</pre>
      </div>

      <p>Return the size in bytes (for all three libraries) of the
      data block pointed to by the <code class="function">study_data</code> field in a <code class="function">pcre_extra</code> block. If <code class="function">pcre_extra</code> is NULL, or there is no study
      data, zero is returned. The fourth argument should point to a
      <em class="parameter"><code>size_t</code></em> variable. The
      <code class="function">study_data</code> field is set by
      <code class="function">pcre_study</code>() to record
      information that will speed up matching (see the section
      entitled "Studying a pattern" above). The format of the
      <code class="function">study_data</code> block is private,
      but its length is made available via this option so that it
      can be saved and restored (see the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation for details).</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_REQUIREDCHARFLAGS
</pre>
      </div>

      <p>Returns 1 if there is a rightmost literal data unit that
      must exist in any matched string, other than at its start.
      The fourth argument should point to an <span class="type">int</span> variable. If there is no such value, 0 is
      returned. If returning 1, the character value itself can be
      retrieved using PCRE_INFO_REQUIREDCHAR.</p>

      <p>For anchored patterns, a last literal value is recorded
      only if it follows something of variable length. For example,
      for the pattern /^a\d+z\d+/ the returned value 1 (with "z"
      returned from PCRE_INFO_REQUIREDCHAR), but for /^a\dz\d/ the
      returned value is 0.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_INFO_REQUIREDCHAR
</pre>
      </div>

      <p>Return the value of the rightmost literal data unit that
      must exist in any matched string, other than at its start, if
      such a value has been recorded. The fourth argument should
      point to an <span class="type">uint32_t</span> variable. If
      there is no such value, 0 is returned.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect12" name="pcreapi-3_sect12" shape="rect"> </a>

      <h2>REFERENCE COUNTS</h2>

      <p><span class="emphasis"><em>int pcre_refcount(pcre
      *<em class="parameter"><code>code</code></em>, int <em class="parameter"><code>adjust</code></em>);</em></span></p>

      <p>The <code class="function">pcre_refcount</code>() function
      is used to maintain a reference count in the data block that
      contains a compiled pattern. It is provided for the benefit
      of applications that operate in an object-oriented manner,
      where different parts of the application may be using the
      same compiled pattern, but you want to free the block when
      they are all done.</p>

      <p>When a pattern is compiled, the reference count field is
      initialized to zero. It is changed only by calling this
      function, whose action is to add the <em class="parameter"><code>adjust</code></em> value (which may be
      positive or negative) to it. The yield of the function is the
      new value. However, the value of the count is constrained to
      lie between 0 and 65535, inclusive. If the new value is
      outside these limits, it is forced to the appropriate limit
      value.</p>

      <p>Except when it is zero, the reference count is not
      correctly preserved if a pattern is compiled on one host and
      then transferred to a host whose byte-order is different.
      (This seems a highly unlikely scenario.)</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect13" name="pcreapi-3_sect13" shape="rect"> </a>

      <h2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre_exec(const pcre *<em class="parameter"><code>code</code></em>, const pcre_extra *<em class="parameter"><code>extra</code></em>,</em></span>
<span class="emphasis"><em>     const char *<em class="parameter"><code>subject</code></em>, int <em class="parameter"><code>length</code></em>, int <em class="parameter"><code>startoffset</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>options</code></em>, int *<em class="parameter"><code>ovector</code></em>, int <em class="parameter"><code>ovecsize</code></em>);</em></span>
</pre>
      </div>

      <p>The function <code class="function">pcre_exec</code>() is
      called to match a subject string against a compiled pattern,
      which is passed in the <em class="parameter"><code>code</code></em> argument. If the pattern
      was studied, the result of the study should be passed in the
      <em class="parameter"><code>extra</code></em> argument. You
      can call <code class="function">pcre_exec</code>() with the
      same <em class="parameter"><code>code</code></em> and
      <em class="parameter"><code>extra</code></em> arguments as
      many times as you like, in order to match different subject
      strings with the same pattern.</p>

      <p>This function is the main matching facility of the
      library, and it operates in a Perl-like manner. For
      specialist use there is also an alternative matching
      function, which is described below in the section about the
      <code class="function">pcre_dfa_exec</code>() function.</p>

      <p>In most applications, the pattern will have been compiled
      (and optionally studied) in the same process that calls
      <code class="function">pcre_exec</code>(). However, it is
      possible to save compiled patterns and study data, and then
      use them later in different processes, possibly even on
      different hosts. For a discussion about this, see the
      <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation.</p>

      <p>Here is an example of a simple call to <code class="function">pcre_exec</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 int ovector[30];
 rc = pcre_exec(
   re,             /* result of pcre_compile() */
   NULL,           /* we didn't study the pattern */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   ovector,        /* vector of integers for substring information */
   30);            /* number of elements (NOT size in bytes) */
</pre>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect14" name="pcreapi-3_sect14" shape="rect"> </a>

        <h3>Extra data for <code class="function">pcre_exec</code>()</h3>

        <p>If the <em class="parameter"><code>extra</code></em>
        argument is not NULL, it must point to a <code class="function">pcre_extra</code> data block. The <code class="function">pcre_study</code>() function returns such a
        block (when it doesn't return NULL), but you can also
        create one for yourself, and pass additional information in
        it. The <code class="function">pcre_extra</code> block
        contains the following fields (not necessarily in this
        order):</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 unsigned long int <code class="function">flags</code>;
 void *<code class="function">study_data</code>;
 void *<code class="function">executable_jit</code>;
 unsigned long int <code class="function">match_limit</code>;
 unsigned long int <code class="function">match_limit_recursion</code>;
 void *<code class="function">callout_data</code>;
 const unsigned char *<em class="parameter"><code>tables</code></em>;
 unsigned char **<code class="function">mark</code>;
</pre>
        </div>

        <p>In the 16-bit version of this structure, the
        <code class="function">mark</code> field has type
        "PCRE_UCHAR16 **".</p>

        <p>In the 32-bit version of this structure, the
        <code class="function">mark</code> field has type
        "PCRE_UCHAR32 **".</p>

        <p>The <code class="function">flags</code> field is used to
        specify which of the other fields are set. The flag bits
        are:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_EXTRA_CALLOUT_DATA
 PCRE_EXTRA_EXECUTABLE_JIT
 PCRE_EXTRA_MARK
 PCRE_EXTRA_MATCH_LIMIT
 PCRE_EXTRA_MATCH_LIMIT_RECURSION
 PCRE_EXTRA_STUDY_DATA
 PCRE_EXTRA_TABLES
</pre>
        </div>

        <p>Other flag bits should be set to zero. The <code class="function">study_data</code> field and sometimes the
        <code class="function">executable_jit</code> field are set
        in the <code class="function">pcre_extra</code> block that
        is returned by <code class="function">pcre_study</code>(),
        together with the appropriate flag bits. You should not set
        these yourself, but you may add to the block by setting
        other fields and their corresponding flag bits.</p>

        <p>The <code class="function">match_limit</code> field
        provides a means of preventing PCRE from using up a vast
        amount of resources when running patterns that are not
        going to match, but which have a very large number of
        possibilities in their search trees. The classic example is
        a pattern that uses nested unlimited repeats.</p>

        <p>Internally, <code class="function">pcre_exec</code>()
        uses a function called <code class="function">match</code>(), which it calls repeatedly
        (sometimes recursively). The limit set by <code class="function">match_limit</code> is imposed on the number of
        times this function is called during a match, which has the
        effect of limiting the amount of backtracking that can take
        place. For patterns that are not anchored, the count
        restarts from zero for each position in the subject
        string.</p>

        <p>When <code class="function">pcre_exec</code>() is called
        with a pattern that was successfully studied with a JIT
        option, the way that the matching is executed is entirely
        different. However, there is still the possibility of
        runaway matching that goes on for a very long time, and so
        the <code class="function">match_limit</code> value is also
        used in this case (but in a different way) to limit how
        long the matching can continue.</p>

        <p>The default value for the limit can be set when PCRE is
        built; the default default is 10 million, which handles all
        but the most extreme cases. You can override the default by
        suppling <code class="function">pcre_exec</code>() with a
        <code class="function">pcre_extra</code> block in which
        <code class="function">match_limit</code> is set, and
        PCRE_EXTRA_MATCH_LIMIT is set in the <code class="function">flags</code> field. If the limit is exceeded,
        <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_MATCHLIMIT.</p>

        <p>A value for the match limit may also be supplied by an
        item at the start of a pattern of the form</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*LIMIT_MATCH=d)
</pre>
        </div>

        <p>where d is a decimal number. However, such a setting is
        ignored unless d is less than the limit set by the caller
        of <code class="function">pcre_exec</code>() or, if no such
        limit is set, less than the default.</p>

        <p>The <code class="function">match_limit_recursion</code>
        field is similar to <code class="function">match_limit</code>, but instead of limiting the
        total number of times that <code class="function">match</code>() is called, it limits the depth of
        recursion. The recursion depth is a smaller number than the
        total number of calls, because not all calls to
        <code class="function">match</code>() are recursive. This
        limit is of use only if it is set smaller than <code class="function">match_limit</code>.</p>

        <p>Limiting the recursion depth limits the amount of
        machine stack that can be used, or, when PCRE has been
        compiled to use memory on the heap instead of the stack,
        the amount of heap memory that can be used. This limit is
        not relevant, and is ignored, when matching is done using
        JIT compiled code.</p>

        <p>The default value for <code class="function">match_limit_recursion</code> can be set when
        PCRE is built; the default default is the same value as the
        default for <code class="function">match_limit</code>. You
        can override the default by suppling <code class="function">pcre_exec</code>() with a <code class="function">pcre_extra</code> block in which <code class="function">match_limit_recursion</code> is set, and
        PCRE_EXTRA_MATCH_LIMIT_RECURSION is set in the <code class="function">flags</code> field. If the limit is exceeded,
        <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_RECURSIONLIMIT.</p>

        <p>A value for the recursion limit may also be supplied by
        an item at the start of a pattern of the form</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*LIMIT_RECURSION=d)
</pre>
        </div>

        <p>where d is a decimal number. However, such a setting is
        ignored unless d is less than the limit set by the caller
        of <code class="function">pcre_exec</code>() or, if no such
        limit is set, less than the default.</p>

        <p>The <code class="function">callout_data</code> field is
        used in conjunction with the "callout" feature, and is
        described in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
        documentation.</p>

        <p>The <em class="parameter"><code>tables</code></em> field
        is provided for use with patterns that have been
        pre-compiled using custom character tables, saved to disc
        or elsewhere, and then reloaded, because the tables that
        were used to compile a pattern are not saved with it. See
        the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
        documentation for a discussion of saving compiled patterns
        for later use. If NULL is passed using this mechanism, it
        forces PCRE's internal tables to be used.</p>

        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Warning">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Warning]" src="../stylesheet/warning.png" /></td>

              <th align="left" rowspan="1" colspan="1">Warning</th>
            </tr>

            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>The tables that <code class="function">pcre_exec</code>() uses must be the same
                as those that were used when the pattern was
                compiled. If this is not the case, the behaviour of
                <code class="function">pcre_exec</code>() is
                undefined. Therefore, when a pattern is compiled
                and matched in the same process, this field should
                never be set. In this (the most common) case, the
                correct table pointer is automatically passed with
                the compiled pattern from <code class="function">pcre_compile</code>() to <code class="function">pcre_exec</code>().</p>
              </td>
            </tr>
          </table>
        </div>

        <p>If PCRE_EXTRA_MARK is set in the <code class="function">flags</code> field, the <code class="function">mark</code> field must be set to point to a
        suitable variable. If the pattern contains any backtracking
        control verbs such as (*MARK:NAME), and the execution ends
        up with a name to pass back, a pointer to the name string
        (zero terminated) is placed in the variable pointed to by
        the <code class="function">mark</code> field. The names are
        within the compiled pattern; if you wish to retain such a
        name you must copy it before freeing the memory of a
        compiled pattern. If there is no name to pass back, the
        variable pointed to by the <code class="function">mark</code> field is set to NULL. For details of
        the backtracking control verbs, see the section entitled
        "Backtracking control" in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect15" name="pcreapi-3_sect15" shape="rect"> </a>

        <h3>Option bits for <code class="function">pcre_exec</code>()</h3>

        <p>The unused bits of the <em class="parameter"><code>options</code></em> argument for
        <code class="function">pcre_exec</code>() must be zero. The
        only bits that may be set are PCRE_ANCHORED,
        PCRE_NEWLINE_<code class="function">xxx</code>,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_NO_START_OPTIMIZE,
        PCRE_NO_UTF8_CHECK, PCRE_PARTIAL_HARD, and
        PCRE_PARTIAL_SOFT.</p>

        <p>If the pattern was successfully studied with one of the
        just-in-time (JIT) compile options, the only supported
        options for JIT execution are PCRE_NO_UTF8_CHECK,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, and
        PCRE_PARTIAL_SOFT. If an unsupported option is used, JIT
        execution is disabled and the normal interpretive code in
        <code class="function">pcre_exec</code>() is run.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ANCHORED
</pre>
        </div>

        <p>The PCRE_ANCHORED option limits <code class="function">pcre_exec</code>() to matching at the first
        matching position. If a pattern was compiled with
        PCRE_ANCHORED, or turned out to be anchored by virtue of
        its contents, it cannot be made unachored at matching
        time.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_BSR_ANYCRLF
 PCRE_BSR_UNICODE
</pre>
        </div>

        <p>These options (which are mutually exclusive) control
        what the \R escape sequence matches. The choice is either
        to match only CR, LF, or CRLF, or to match any Unicode
        newline sequence. These options override the choice that
        was made or defaulted when the pattern was compiled.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_NEWLINE_CR
 PCRE_NEWLINE_LF
 PCRE_NEWLINE_CRLF
 PCRE_NEWLINE_ANYCRLF
 PCRE_NEWLINE_ANY
</pre>
        </div>

        <p>These options override the newline definition that was
        chosen or defaulted when the pattern was compiled. For
        details, see the description of <code class="function">pcre_compile</code>() above. During matching,
        the newline choice affects the behaviour of the dot,
        circumflex, and dollar metacharacters. It may also alter
        the way the match position is advanced after a match
        failure for an unanchored pattern.</p>

        <p>When PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or
        PCRE_NEWLINE_ANY is set, and a match attempt for an
        unanchored pattern fails when the current position is at a
        CRLF sequence, and the pattern contains no explicit matches
        for CR or LF characters, the match position is advanced by
        two characters instead of one, in other words, to after the
        CRLF.</p>

        <p>The above rule is a compromise that makes the most
        common cases work as expected. For example, if the pattern
        is .+A (and the PCRE_DOTALL option is not set), it does not
        match the string "\r\nA" because, after failing at the
        start, it skips both the CR and the LF before retrying.
        However, the pattern [\r\n]A does match that string,
        because it contains an explicit CR or LF reference, and so
        advances only by one character after the first failure.</p>

        <p>An explicit match for CR of LF is either a literal
        appearance of one of those characters, or one of the \r or
        \n escape sequences. Implicit matches such as [^X] do not
        count, nor does \s (which includes CR and LF in the
        characters that it matches).</p>

        <p>Notwithstanding the above, anomalous effects may still
        occur when CRLF is a valid newline sequence and explicit \r
        or \n escapes appear in the pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_NOTBOL
</pre>
        </div>

        <p>This option specifies that first character of the
        subject string is not the beginning of a line, so the
        circumflex metacharacter should not match before it.
        Setting this without PCRE_MULTILINE (at compile time)
        causes circumflex never to match. This option affects only
        the behaviour of the circumflex metacharacter. It does not
        affect \A.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_NOTEOL
</pre>
        </div>

        <p>This option specifies that the end of the subject string
        is not the end of a line, so the dollar metacharacter
        should not match it nor (except in multiline mode) a
        newline immediately before it. Setting this without
        PCRE_MULTILINE (at compile time) causes dollar never to
        match. This option affects only the behaviour of the dollar
        metacharacter. It does not affect \Z or \z.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_NOTEMPTY
</pre>
        </div>

        <p>An empty string is not considered to be a valid match if
        this option is set. If there are alternatives in the
        pattern, they are tried. If all the alternatives match the
        empty string, the entire match fails. For example, if the
        pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
a?b?
</pre>
        </div>

        <p>is applied to a string not beginning with "a" or "b", it
        matches an empty string at the start of the subject. With
        PCRE_NOTEMPTY set, this match is not valid, so PCRE
        searches further into the string for occurrences of "a" or
        "b".</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_NOTEMPTY_ATSTART
</pre>
        </div>

        <p>This is like PCRE_NOTEMPTY, except that an empty string
        match that is not at the start of the subject is permitted.
        If the pattern is anchored, such a match can occur only if
        the pattern contains \K.</p>

        <p>Perl has no direct equivalent of PCRE_NOTEMPTY or
        PCRE_NOTEMPTY_ATSTART, but it does make a special case of a
        pattern match of the empty string within its <code class="function">split</code>() function, and when using the /g
        modifier. It is possible to emulate Perl's behaviour after
        matching a null string by first trying the match again at
        the same offset with PCRE_NOTEMPTY_ATSTART and
        PCRE_ANCHORED, and then if that fails, by advancing the
        starting offset (see below) and trying an ordinary match
        again. There is some code that demonstrates how to do this
        in the <a class="link" href="../htmlman3/pcredemo.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span></a> sample
        program. In the most general case, you have to check to see
        if the newline convention recognizes CRLF as a newline, and
        if so, and the current character is CR followed by LF,
        advance the starting offset by two characters instead of
        one.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_NO_START_OPTIMIZE
</pre>
        </div>

        <p>There are a number of optimizations that <code class="function">pcre_exec</code>() uses at the start of a match,
        in order to speed up the process. For example, if it is
        known that an unanchored match must start with a specific
        character, it searches the subject for that character, and
        fails immediately if it cannot find it, without actually
        running the main matching function. This means that a
        special item such as (*COMMIT) at the start of a pattern is
        not considered until after a suitable starting point for
        the match has been found. Also, when callouts or (*MARK)
        items are in use, these "start-up" optimizations can cause
        them to be skipped if the pattern is never actually used.
        The start-up optimizations are in effect a pre-scan of the
        subject that takes place before the pattern is run.</p>

        <p>The PCRE_NO_START_OPTIMIZE option disables the start-up
        optimizations, possibly causing performance to suffer, but
        ensuring that in cases where the result is "no match", the
        callouts do occur, and that items such as (*COMMIT) and
        (*MARK) are considered at every possible starting position
        in the subject string. If PCRE_NO_START_OPTIMIZE is set at
        compile time, it cannot be unset at matching time. The use
        of PCRE_NO_START_OPTIMIZE at matching time (that is,
        passing it to <code class="function">pcre_exec</code>())
        disables JIT execution; in this situation, matching is
        always done using interpretively.</p>

        <p>Setting PCRE_NO_START_OPTIMIZE can change the outcome of
        a matching operation. Consider the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*COMMIT)ABC
</pre>
        </div>

        <p>When this is compiled, PCRE records the fact that a
        match must start with the character "A". Suppose the
        subject string is "DEFABC". The start-up optimization scans
        along the subject, finds "A" and runs the first match
        attempt from there. The (*COMMIT) item means that the
        pattern must match the current starting position, which in
        this case, it does. However, if the same match is run with
        PCRE_NO_START_OPTIMIZE set, the initial scan along the
        subject string does not happen. The first match attempt is
        run starting from "D" and when this fails, (*COMMIT)
        prevents any further matches being tried, so the overall
        result is "no match". If the pattern is studied, more
        start-up optimizations may be used. For example, a minimum
        length for the subject may be recorded. Consider the
        pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*MARK:A)(X|Y)
</pre>
        </div>

        <p>The minimum length for a match is one character. If the
        subject is "ABC", there will be attempts to match "ABC",
        "BC", "C", and then finally an empty string. If the pattern
        is studied, the final attempt does not take place, because
        PCRE knows that the subject is too short, and so the
        (*MARK) is never encountered. In this case, studying the
        pattern does not affect the overall match result, which is
        still "no match", but it does affect the auxiliary
        information that is returned.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_NO_UTF8_CHECK
</pre>
        </div>

        <p>When PCRE_UTF8 is set at compile time, the validity of
        the subject as a UTF-8 string is automatically checked when
        <code class="function">pcre_exec</code>() is subsequently
        called. The entire string is checked before any other
        processing takes place. The value of <em class="parameter"><code>startoffset</code></em> is also checked
        to ensure that it points to the start of a UTF-8 character.
        There is a discussion about the validity of UTF-8 strings
        in the <a class="link" href="../htmlman3/pcreunicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreunicode</span>(3)</span></a> page. If
        an invalid sequence of bytes is found, <code class="function">pcre_exec</code>() returns the error
        PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is set and the
        problem is a truncated character at the end of the subject,
        PCRE_ERROR_SHORTUTF8. In both cases, information about the
        precise nature of the error may also be returned (see the
        descriptions of these errors in the section entitled
        <span class="emphasis"><em>Error return values
        from</em></span> <code class="function">pcre_exec</code>()
        below). If <em class="parameter"><code>startoffset</code></em> contains a value
        that does not point to the start of a UTF-8 character (or
        to the end of the subject), PCRE_ERROR_BADUTF8_OFFSET is
        returned.</p>

        <p>If you already know that your subject is valid, and you
        want to skip these checks for performance reasons, you can
        set the PCRE_NO_UTF8_CHECK option when calling <code class="function">pcre_exec</code>(). You might want to do this
        for the second and subsequent calls to <code class="function">pcre_exec</code>() if you are making repeated
        calls to find all the matches in a single subject string.
        However, you should be sure that the value of <em class="parameter"><code>startoffset</code></em> points to the
        start of a character (or the end of the subject). When
        PCRE_NO_UTF8_CHECK is set, the effect of passing an invalid
        string as a subject or an invalid value of <em class="parameter"><code>startoffset</code></em> is undefined.
        Your program may crash or loop.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_PARTIAL_HARD
 PCRE_PARTIAL_SOFT
</pre>
        </div>

        <p>These options turn on the partial matching feature. For
        backwards compatibility, PCRE_PARTIAL is a synonym for
        PCRE_PARTIAL_SOFT. A partial match occurs if the end of the
        subject string is reached successfully, but there are not
        enough subject characters to complete the match. If this
        happens when PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD)
        is set, matching continues by testing any remaining
        alternatives. Only if no complete match can be found is
        PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH.
        In other words, PCRE_PARTIAL_SOFT says that the caller is
        prepared to handle a partial match, but only if no complete
        match can be found.</p>

        <p>If PCRE_PARTIAL_HARD is set, it overrides
        PCRE_PARTIAL_SOFT. In this case, if a partial match is
        found, <code class="function">pcre_exec</code>()
        immediately returns PCRE_ERROR_PARTIAL, without considering
        any other alternatives. In other words, when
        PCRE_PARTIAL_HARD is set, a partial match is considered to
        be more important that an alternative complete match.</p>

        <p>In both cases, the portion of the string that was
        inspected when the partial match was found is set as the
        first matching string. There is a more detailed discussion
        of partial and multi-segment matching, with examples, in
        the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect16" name="pcreapi-3_sect16" shape="rect"> </a>

        <h3>The string to be matched by <code class="function">pcre_exec</code>()</h3>

        <p>The subject string is passed to <code class="function">pcre_exec</code>() as a pointer in <em class="parameter"><code>subject</code></em>, a length in
        <em class="parameter"><code>length</code></em>, and a
        starting offset in <em class="parameter"><code>startoffset</code></em>. The units for
        <em class="parameter"><code>length</code></em> and
        <em class="parameter"><code>startoffset</code></em> are
        bytes for the 8-bit library, 16-bit data items for the
        16-bit library, and 32-bit data items for the 32-bit
        library.</p>

        <p>If <em class="parameter"><code>startoffset</code></em>
        is negative or greater than the length of the subject,
        <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_BADOFFSET. When the starting offset is zero, the
        search for a match starts at the beginning of the subject,
        and this is by far the most common case. In UTF-8 or UTF-16
        mode, the offset must point to the start of a character, or
        the end of the subject (in UTF-32 mode, one data unit
        equals one character, so all offsets are valid). Unlike the
        pattern string, the subject may contain binary zeroes.</p>

        <p>A non-zero starting offset is useful when searching for
        another match in the same subject by calling <code class="function">pcre_exec</code>() again after a previous
        success. Setting <em class="parameter"><code>startoffset</code></em> differs from just
        passing over a shortened string and setting PCRE_NOTBOL in
        the case of a pattern that begins with any kind of
        lookbehind. For example, consider the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
\Biss\B
</pre>
        </div>

        <p>which finds occurrences of "iss" in the middle of words.
        (\B matches only if the current position in the subject is
        not a word boundary.) When applied to the string
        "Mississipi" the first call to <code class="function">pcre_exec</code>() finds the first occurrence.
        If <code class="function">pcre_exec</code>() is called
        again with just the remainder of the subject, namely
        "issipi", it does not match, because \B is always false at
        the start of the subject, which is deemed to be a word
        boundary. However, if <code class="function">pcre_exec</code>() is passed the entire string
        again, but with <em class="parameter"><code>startoffset</code></em> set to 4, it
        finds the second occurrence of "iss" because it is able to
        look behind the starting point to discover that it is
        preceded by a letter.</p>

        <p>Finding all the matches in a subject is tricky when the
        pattern can match an empty string. It is possible to
        emulate Perl's /g behaviour by first trying the match again
        at the same offset, with the PCRE_NOTEMPTY_ATSTART and
        PCRE_ANCHORED options, and then if that fails, advancing
        the starting offset and trying an ordinary match again.
        There is some code that demonstrates how to do this in the
        <a class="link" href="../htmlman3/pcredemo.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span></a> sample
        program. In the most general case, you have to check to see
        if the newline convention recognizes CRLF as a newline, and
        if so, and the current character is CR followed by LF,
        advance the starting offset by two characters instead of
        one.</p>

        <p>If a non-zero starting offset is passed when the pattern
        is anchored, one attempt to match at the given offset is
        made. This can only succeed if the pattern does not require
        the match to be at the start of the subject.</p>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect17" name="pcreapi-3_sect17" shape="rect"> </a>

        <h3>How <code class="function">pcre_exec</code>() returns
        captured substrings</h3>

        <p>In general, a pattern matches a certain portion of the
        subject, and in addition, further substrings from the
        subject may be picked out by parts of the pattern.
        Following the usage in Jeffrey Friedl's book, this is
        called "capturing" in what follows, and the phrase
        "capturing subpattern" is used for a fragment of a pattern
        that picks out a substring. PCRE supports several other
        kinds of parenthesized subpattern that do not cause
        substrings to be captured.</p>

        <p>Captured substrings are returned to the caller via a
        vector of integers whose address is passed in <em class="parameter"><code>ovector</code></em>. The number of
        elements in the vector is passed in <em class="parameter"><code>ovecsize</code></em>, which must be a
        non-negative number. <code class="function">Note</code>:
        this argument is NOT the size of <em class="parameter"><code>ovector</code></em> in bytes.</p>

        <p>The first two-thirds of the vector is used to pass back
        captured substrings, each substring using a pair of
        integers. The remaining third of the vector is used as
        workspace by <code class="function">pcre_exec</code>()
        while matching capturing subpatterns, and is not available
        for passing back information. The number passed in
        <em class="parameter"><code>ovecsize</code></em> should
        always be a multiple of three. If it is not, it is rounded
        down.</p>

        <p>When a match is successful, information about captured
        substrings is returned in pairs of integers, starting at
        the beginning of <em class="parameter"><code>ovector</code></em>, and continuing up to
        two-thirds of its length at the most. The first element of
        each pair is set to the offset of the first character in a
        substring, and the second is set to the offset of the first
        character after the end of a substring. These values are
        always data unit offsets, even in UTF mode. They are byte
        offsets in the 8-bit library, 16-bit data item offsets in
        the 16-bit library, and 32-bit data item offsets in the
        32-bit library. <code class="function">Note</code>: they
        are not character counts.</p>

        <p>The first pair of integers, <em class="replaceable"><code>ovector[0]</code></em> and <em class="replaceable"><code>ovector[1]</code></em>, identify the
        portion of the subject string matched by the entire
        pattern. The next pair is used for the first capturing
        subpattern, and so on. The value returned by <code class="function">pcre_exec</code>() is one more than the highest
        numbered pair that has been set. For example, if two
        substrings have been captured, the returned value is 3. If
        there are no capturing subpatterns, the return value from a
        successful match is 1, indicating that just the first pair
        of offsets has been set.</p>

        <p>If a capturing subpattern is matched repeatedly, it is
        the last portion of the string that it matched that is
        returned.</p>

        <p>If the vector is too small to hold all the captured
        substring offsets, it is used as far as possible (up to
        two-thirds of its length), and the function returns a value
        of zero. If neither the actual string matched nor any
        captured substrings are of interest, <code class="function">pcre_exec</code>() may be called with <em class="parameter"><code>ovector</code></em> passed as NULL and
        <em class="parameter"><code>ovecsize</code></em> as zero.
        However, if the pattern contains back references and the
        <em class="parameter"><code>ovector</code></em> is not big
        enough to remember the related substrings, PCRE has to get
        additional memory for use during matching. Thus it is
        usually advisable to supply an <em class="parameter"><code>ovector</code></em> of reasonable
        size.</p>

        <p>There are some cases where zero is returned (indicating
        vector overflow) when in fact the vector is exactly the
        right size for the final match. For example, consider the
        pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(a)(?:(b)c|bd)
</pre>
        </div>

        <p>If a vector of 6 elements (allowing for only 1 captured
        substring) is given with subject string "abd", <code class="function">pcre_exec</code>() will try to set the second
        captured string, thereby recording a vector overflow,
        before failing to match "c" and backing up to try the
        second alternative. The zero return, however, does
        correctly indicate that the maximum number of slots (namely
        2) have been filled. In similar cases where there is
        temporary overflow, but the final number of used slots is
        actually less than the maximum, a non-zero value is
        returned.</p>

        <p>The <code class="function">pcre_fullinfo</code>()
        function can be used to find out how many capturing
        subpatterns there are in a compiled pattern. The smallest
        size for <em class="parameter"><code>ovector</code></em>
        that will allow for <code class="literal">n</code> captured
        substrings, in addition to the offsets of the substring
        matched by the whole pattern, is (<code class="literal">n</code>+1)*3.</p>

        <p>It is possible for capturing subpattern number
        <em class="replaceable"><code>n+1</code></em> to match some
        part of the subject when subpattern <code class="literal">n</code> has not been used at all. For example,
        if the string "abc" is matched against the pattern
        (a|(z))(bc) the return from the function is 4, and
        subpatterns 1 and 3 are matched, but 2 is not. When this
        happens, both values in the offset pairs corresponding to
        unused subpatterns are set to -1.</p>

        <p>Offset values that correspond to unused subpatterns at
        the end of the expression are also set to -1. For example,
        if the string "abc" is matched against the pattern
        (abc)(x(yz)?)? subpatterns 2 and 3 are not matched. The
        return from the function is 2, because the highest used
        capturing subpattern number is 1, and the offsets for for
        the second and third capturing subpatterns (assuming the
        vector is large enough, of course) are set to -1.</p>

        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Note">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Note]" src="../stylesheet/note.png" /></td>

              <th align="left" rowspan="1" colspan="1">Note</th>
            </tr>

            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>Elements in the first two-thirds of <em class="parameter"><code>ovector</code></em> that do not
                correspond to capturing parentheses in the pattern
                are never changed. That is, if a pattern contains
                <code class="literal">n</code> capturing
                parentheses, no more than <em class="replaceable"><code>ovector[0]</code></em> to
                <em class="replaceable"><code>ovector[2n+1]</code></em> are
                set by <code class="function">pcre_exec</code>().
                The other elements (in the first two-thirds) retain
                whatever values they previously had.</p>
              </td>
            </tr>
          </table>
        </div>

        <p>Some convenience functions are provided for extracting
        the captured substrings as separate strings. These are
        described below.</p>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect18" name="pcreapi-3_sect18" shape="rect"> </a>

        <h3>Error return values from <code class="function">pcre_exec</code>()</h3>

        <p>If <code class="function">pcre_exec</code>() fails, it
        returns a negative number. The following are defined in the
        header file:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMATCH        (-1)
</pre>
        </div>

        <p>The subject string did not match the pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NULL           (-2)
</pre>
        </div>

        <p>Either <em class="parameter"><code>code</code></em> or
        <em class="parameter"><code>subject</code></em> was passed
        as NULL, or <em class="parameter"><code>ovector</code></em>
        was NULL and <em class="parameter"><code>ovecsize</code></em> was not zero.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADOPTION      (-3)
</pre>
        </div>

        <p>An unrecognized bit was set in the <em class="parameter"><code>options</code></em> argument.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADMAGIC       (-4)
</pre>
        </div>

        <p>PCRE stores a 4-byte "magic number" at the start of the
        compiled code, to catch the case when it is passed a junk
        pointer and to detect when a pattern that was compiled in
        an environment of one endianness is run in an environment
        with the other endianness. This is the error that PCRE
        gives when the magic number is not present.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_UNKNOWN_OPCODE (-5)
</pre>
        </div>

        <p>While running the pattern match, an unknown item was
        encountered in the compiled pattern. This error could be
        caused by a bug in PCRE or by overwriting of the compiled
        pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
        </div>

        <p>If a pattern contains back references, but the
        <em class="parameter"><code>ovector</code></em> that is
        passed to <code class="function">pcre_exec</code>() is not
        big enough to remember the referenced substrings, PCRE gets
        a block of memory at the start of matching to use for this
        purpose. If the call via <code class="function">pcre_malloc</code>() fails, this error is given.
        The memory is automatically freed at the end of
        matching.</p>

        <p>This error is also given if <code class="function">pcre_stack_malloc</code>() fails in <code class="function">pcre_exec</code>(). This can happen only when
        PCRE has been compiled with <code class="option">−−disable−stack−for−recursion</code>.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
        </div>

        <p>This error is used by the <code class="function">pcre_copy_substring</code>(), <code class="function">pcre_get_substring</code>(), and <code class="function">pcre_get_substring_list</code>() functions (see
        below). It is never returned by <code class="function">pcre_exec</code>().</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_MATCHLIMIT     (-8)
</pre>
        </div>

        <p>The backtracking limit, as specified by the <code class="function">match_limit</code> field in a <code class="function">pcre_extra</code> structure (or defaulted) was
        reached. See the description above.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_CALLOUT        (-9)
</pre>
        </div>

        <p>This error is never generated by <code class="function">pcre_exec</code>() itself. It is provided for
        use by callout functions that want to yield a distinctive
        error code. See the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
        documentation for details.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADUTF8        (-10)
</pre>
        </div>

        <p>A string that contains an invalid UTF-8 byte sequence
        was passed as a subject, and the PCRE_NO_UTF8_CHECK option
        was not set. If the size of the output vector (<em class="parameter"><code>ovecsize</code></em>) is at least 2, the
        byte offset to the start of the the invalid UTF-8 character
        is placed in the first element, and a reason code is placed
        in the second element. The reason codes are listed in the
        following section. For backward compatibility, if
        PCRE_PARTIAL_HARD is set and the problem is a truncated
        UTF-8 character at the end of the subject (reason codes 1
        to 5), PCRE_ERROR_SHORTUTF8 is returned instead of
        PCRE_ERROR_BADUTF8.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADUTF8_OFFSET (-11)
</pre>
        </div>

        <p>The UTF-8 byte sequence that was passed as a subject was
        checked and found to be valid (the PCRE_NO_UTF8_CHECK
        option was not set), but the value of <em class="parameter"><code>startoffset</code></em> did not point to
        the beginning of a UTF-8 character or the end of the
        subject.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_PARTIAL        (-12)
</pre>
        </div>

        <p>The subject string did not match, but it did match
        partially. See the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation for details of partial matching.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADPARTIAL     (-13)
</pre>
        </div>

        <p>This code is no longer in use. It was formerly returned
        when the PCRE_PARTIAL option was used with a compiled
        pattern containing items that were not supported for
        partial matching. From release 8.00 onwards, there are no
        restrictions on partial matching.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_INTERNAL       (-14)
</pre>
        </div>

        <p>An unexpected internal error has occurred. This error
        could be caused by a bug in PCRE or by overwriting of the
        compiled pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADCOUNT       (-15)
</pre>
        </div>

        <p>This error is given if the value of the <em class="parameter"><code>ovecsize</code></em> argument is
        negative.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_RECURSIONLIMIT (-21)
</pre>
        </div>

        <p>The internal recursion limit, as specified by the
        <code class="function">match_limit_recursion</code> field
        in a <code class="function">pcre_extra</code> structure (or
        defaulted) was reached. See the description above.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADNEWLINE     (-23)
</pre>
        </div>

        <p>An invalid combination of PCRE_NEWLINE_<code class="function">xxx</code> options was given.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADOFFSET      (-24)
</pre>
        </div>

        <p>The value of <em class="parameter"><code>startoffset</code></em> was negative or
        greater than the length of the subject, that is, the value
        in <em class="parameter"><code>length</code></em>.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_SHORTUTF8      (-25)
</pre>
        </div>

        <p>This error is returned instead of PCRE_ERROR_BADUTF8
        when the subject string ends with a truncated UTF-8
        character and the PCRE_PARTIAL_HARD option is set.
        Information about the failure is returned as for
        PCRE_ERROR_BADUTF8. It is in fact sufficient to detect this
        case, but this special error code for PCRE_PARTIAL_HARD
        precedes the implementation of returned information; it is
        retained for backwards compatibility.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_RECURSELOOP    (-26)
</pre>
        </div>

        <p>This error is returned when <code class="function">pcre_exec</code>() detects a recursion loop
        within the pattern. Specifically, it means that either the
        whole pattern or a subpattern has been called recursively
        for the second time at the same position in the subject
        string. Some simple patterns that might do this are
        detected and faulted at compile time, but more complicated
        cases, in particular mutual recursions between two
        different subpatterns, cannot be detected until run
        time.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_JIT_STACKLIMIT (-27)
</pre>
        </div>

        <p>This error is returned when a pattern that was
        successfully studied using a JIT compile option is being
        matched, but the memory available for the just-in-time
        processing stack is not large enough. See the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a> documentation
        for more details.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADMODE        (-28)
</pre>
        </div>

        <p>This error is given if a pattern that was compiled by
        the 8-bit library is passed to a 16-bit or 32-bit library
        function, or vice versa.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADENDIANNESS  (-29)
</pre>
        </div>

        <p>This error is given if a pattern that was compiled and
        saved is reloaded on a host with different endianness. The
        utility function <code class="function">pcre_pattern_to_host_byte_order</code>() can be
        used to convert such a pattern so that it runs on the new
        host.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_JIT_BADOPTION
</pre>
        </div>

        <p>This error is returned when a pattern that was
        successfully studied using a JIT compile option is being
        matched, but the matching mode (partial or complete match)
        does not correspond to any JIT compilation mode. When the
        JIT fast path function is used, this error may be also
        given for invalid options. See the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a> documentation
        for more details.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADLENGTH      (-32)
</pre>
        </div>

        <p>This error is given if <code class="function">pcre_exec</code>() is called with a negative
        value for the <em class="parameter"><code>length</code></em> argument.</p>

        <p>Error numbers -16 to -20, -22, and 30 are not used by
        <code class="function">pcre_exec</code>().</p>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect19" name="pcreapi-3_sect19" shape="rect"> </a>

        <h3>Reason codes for invalid UTF-8 strings</h3>

        <p>This section applies only to the 8-bit library. The
        corresponding information for the 16-bit and 32-bit
        libraries is given in the <a class="link" href="../htmlman3/pcre16.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre16</span>(3)</span></a> and <a class="link" href="../htmlman3/pcre32.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre32</span>(3)</span></a> pages.</p>

        <p>When <code class="function">pcre_exec</code>() returns
        either PCRE_ERROR_BADUTF8 or PCRE_ERROR_SHORTUTF8, and the
        size of the output vector (<em class="parameter"><code>ovecsize</code></em>) is at least 2, the
        offset of the start of the invalid UTF-8 character is
        placed in the first output vector element (<em class="replaceable"><code>ovector[0]</code></em>) and a reason
        code is placed in the second element (<em class="replaceable"><code>ovector[1]</code></em>). The reason
        codes are given names in the <code class="filename">pcre.h</code> header file:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR1
 PCRE_UTF8_ERR2
 PCRE_UTF8_ERR3
 PCRE_UTF8_ERR4
 PCRE_UTF8_ERR5
</pre>
        </div>

        <p>The string ends with a truncated UTF-8 character; the
        code specifies how many bytes are missing (1 to 5).
        Although RFC 3629 restricts UTF-8 characters to be no
        longer than 4 bytes, the encoding scheme (originally
        defined by RFC 2279) allows for up to 6 bytes, and this is
        checked first; hence the possibility of 4 or 5 missing
        bytes.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR6
 PCRE_UTF8_ERR7
 PCRE_UTF8_ERR8
 PCRE_UTF8_ERR9
 PCRE_UTF8_ERR10
</pre>
        </div>

        <p>The two most significant bits of the 2nd, 3rd, 4th, 5th,
        or 6th byte of the character do not have the binary value
        0b10 (that is, either the most significant bit is 0, or the
        next bit is 1).</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR11
 PCRE_UTF8_ERR12
</pre>
        </div>

        <p>A character that is valid by the RFC 2279 rules is
        either 5 or 6 bytes long; these code points are excluded by
        RFC 3629.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_UTF8_ERR13
</pre>
        </div>

        <p>A 4-byte character has a value greater than 0x10fff;
        these code points are excluded by RFC 3629.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_UTF8_ERR14
</pre>
        </div>

        <p>A 3-byte character has a value in the range 0xd800 to
        0xdfff; this range of code points are reserved by RFC 3629
        for use with UTF-16, and so are excluded from UTF-8.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR15
 PCRE_UTF8_ERR16
 PCRE_UTF8_ERR17
 PCRE_UTF8_ERR18
 PCRE_UTF8_ERR19
</pre>
        </div>

        <p>A 2-, 3-, 4-, 5-, or 6-byte character is "overlong",
        that is, it codes for a value that can be represented by
        fewer bytes, which is invalid. For example, the two bytes
        0xc0, 0xae give the value 0x2e, whose correct coding uses
        just one byte.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_UTF8_ERR20
</pre>
        </div>

        <p>The two most significant bits of the first byte of a
        character have the binary value 0b10 (that is, the most
        significant bit is 1 and the second is 0). Such a byte can
        only validly occur as the second or subsequent byte of a
        multi-byte character.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_UTF8_ERR21
</pre>
        </div>

        <p>The first byte of a character has the value 0xfe or
        0xff. These values can never occur in a valid UTF-8
        string.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_UTF8_ERR22
</pre>
        </div>

        <p>This error code was formerly used when the presence of a
        so-called "non-character" caused an error. Unicode
        corrigendum #9 makes it clear that such characters should
        not cause a string to be rejected, and so this code is no
        longer in use and is never returned.</p>
      </div>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect20" name="pcreapi-3_sect20" shape="rect"> </a>

      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre_copy_substring(const char *<em class="parameter"><code>subject</code></em>, int *<em class="parameter"><code>ovector</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>stringcount</code></em>, int <em class="parameter"><code>stringnumber</code></em>, char *<em class="parameter"><code>buffer</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>buffersize</code></em>);</em></span>

<span class="emphasis"><em>int pcre_get_substring(const char *<em class="parameter"><code>subject</code></em>, int *<em class="parameter"><code>ovector</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>stringcount</code></em>, int <em class="parameter"><code>stringnumber</code></em>,</em></span>
<span class="emphasis"><em>     const char **<em class="parameter"><code>stringptr</code></em>);</em></span>

<span class="emphasis"><em>int pcre_get_substring_list(const char *<em class="parameter"><code>subject</code></em>,</em></span>
<span class="emphasis"><em>     int *<em class="parameter"><code>ovector</code></em>, int <em class="parameter"><code>stringcount</code></em>, const char ***<em class="parameter"><code>listptr</code></em>);</em></span>
</pre>
      </div>

      <p>Captured substrings can be accessed directly by using the
      offsets returned by <code class="function">pcre_exec</code>()
      in <em class="parameter"><code>ovector</code></em>. For
      convenience, the functions <code class="function">pcre_copy_substring</code>(), <code class="function">pcre_get_substring</code>(), and <code class="function">pcre_get_substring_list</code>() are provided for
      extracting captured substrings as new, separate,
      zero-terminated strings. These functions identify substrings
      by number. The next section describes functions for
      extracting named substrings.</p>

      <p>A substring that contains a binary zero is correctly
      extracted and has a further zero added on the end, but the
      result is not, of course, a C string. However, you can
      process such a string by referring to the length that is
      returned by <code class="function">pcre_copy_substring</code>() and <code class="function">pcre_get_substring</code>(). Unfortunately, the
      interface to <code class="function">pcre_get_substring_list</code>() is not adequate
      for handling strings containing binary zeros, because the end
      of the final string is not independently indicated.</p>

      <p>The first three arguments are the same for all three of
      these functions: <em class="parameter"><code>subject</code></em> is the subject string
      that has just been successfully matched, <em class="parameter"><code>ovector</code></em> is a pointer to the
      vector of integer offsets that was passed to <code class="function">pcre_exec</code>(), and <em class="parameter"><code>stringcount</code></em> is the number of
      substrings that were captured by the match, including the
      substring that matched the entire regular expression. This is
      the value returned by <code class="function">pcre_exec</code>() if it is greater than zero. If
      <code class="function">pcre_exec</code>() returned zero,
      indicating that it ran out of space in <em class="parameter"><code>ovector</code></em>, the value passed as
      <em class="parameter"><code>stringcount</code></em> should be
      the number of elements in the vector divided by three.</p>

      <p>The functions <code class="function">pcre_copy_substring</code>() and <code class="function">pcre_get_substring</code>() extract a single
      substring, whose number is given as <em class="parameter"><code>stringnumber</code></em>. A value of zero
      extracts the substring that matched the entire pattern,
      whereas higher values extract the captured substrings. For
      <code class="function">pcre_copy_substring</code>(), the
      string is placed in <em class="parameter"><code>buffer</code></em>, whose length is given
      by <em class="parameter"><code>buffersize</code></em>, while
      for <code class="function">pcre_get_substring</code>() a new
      block of memory is obtained via <code class="function">pcre_malloc</code>, and its address is returned
      via <em class="parameter"><code>stringptr</code></em>. The
      yield of the function is the length of the string, not
      including the terminating zero, or one of these error
      codes:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
      </div>

      <p>The buffer was too small for <code class="function">pcre_copy_substring</code>(), or the attempt to
      get memory failed for <code class="function">pcre_get_substring</code>().</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
      </div>

      <p>There is no substring whose number is <em class="parameter"><code>stringnumber</code></em>.</p>

      <p>The <code class="function">pcre_get_substring_list</code>() function extracts
      all available substrings and builds a list of pointers to
      them. All this is done in a single block of memory that is
      obtained via <code class="function">pcre_malloc</code>. The
      address of the memory block is returned via <em class="parameter"><code>listptr</code></em>, which is also the
      start of the list of string pointers. The end of the list is
      marked by a NULL pointer. The yield of the function is zero
      if all went well, or the error code</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
      </div>

      <p>if the attempt to get the memory block failed.</p>

      <p>When any of these functions encounter a substring that is
      unset, which can happen when capturing subpattern number
      <em class="replaceable"><code>n+1</code></em> matches some
      part of the subject, but subpattern <code class="literal">n</code> has not been used at all, they return an
      empty string. This can be distinguished from a genuine
      zero-length substring by inspecting the appropriate offset in
      <em class="parameter"><code>ovector</code></em>, which is
      negative for unset substrings.</p>

      <p>The two convenience functions <code class="function">pcre_free_substring</code>() and <code class="function">pcre_free_substring_list</code>() can be used to
      free the memory returned by a previous call of <code class="function">pcre_get_substring</code>() or <code class="function">pcre_get_substring_list</code>(), respectively.
      They do nothing more than call the function pointed to by
      <code class="function">pcre_free</code>, which of course
      could be called directly from a C program. However, PCRE is
      used in some situations where it is linked via a special
      interface to another programming language that cannot use
      <code class="function">pcre_free</code> directly; it is for
      these cases that the functions are provided.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect21" name="pcreapi-3_sect21" shape="rect"> </a>

      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NAME</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre_get_stringnumber(const pcre *<em class="parameter"><code>code</code></em>,</em></span>
<span class="emphasis"><em>     const char *<em class="parameter"><code>name</code></em>);</em></span>

<span class="emphasis"><em>int pcre_copy_named_substring(const pcre *<em class="parameter"><code>code</code></em>,</em></span>
<span class="emphasis"><em>     const char *<em class="parameter"><code>subject</code></em>, int *<em class="parameter"><code>ovector</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>stringcount</code></em>, const char *<em class="parameter"><code>stringname</code></em>,</em></span>
<span class="emphasis"><em>     char *<em class="parameter"><code>buffer</code></em>, int <em class="parameter"><code>buffersize</code></em>);</em></span>

<span class="emphasis"><em>int pcre_get_named_substring(const pcre *<em class="parameter"><code>code</code></em>,</em></span>
<span class="emphasis"><em>     const char *<em class="parameter"><code>subject</code></em>, int *<em class="parameter"><code>ovector</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>stringcount</code></em>, const char *<em class="parameter"><code>stringname</code></em>,</em></span>
<span class="emphasis"><em>     const char **<em class="parameter"><code>stringptr</code></em>);</em></span>
</pre>
      </div>

      <p>To extract a substring by name, you first have to find
      associated number. For example, for this pattern</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
(a+)b(?&lt;xxx&gt;\d+)...
</pre>
      </div>

      <p>the number of the subpattern called "xxx" is 2. If the
      name is known to be unique (PCRE_DUPNAMES was not set), you
      can find the number from the name by calling <code class="function">pcre_get_stringnumber</code>(). The first argument
      is the compiled pattern, and the second is the name. The
      yield of the function is the subpattern number, or
      PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of that
      name.</p>

      <p>Given the number, you can extract the substring directly,
      or use one of the functions described in the previous
      section. For convenience, there are also two functions that
      do the whole job.</p>

      <p>Most of the arguments of <code class="function">pcre_copy_named_substring</code>() and
      <code class="function">pcre_get_named_substring</code>() are
      the same as those for the similarly named functions that
      extract by number. As these are described in the previous
      section, they are not re-described here. There are just two
      differences:</p>

      <p>First, instead of a substring number, a substring name is
      given. Second, there is an extra argument, given at the
      start, which is a pointer to the compiled pattern. This is
      needed in order to gain access to the name-to-number
      translation table.</p>

      <p>These functions call <code class="function">pcre_get_stringnumber</code>(), and if it
      succeeds, they then call <code class="function">pcre_copy_substring</code>() or <code class="function">pcre_get_substring</code>(), as appropriate.
      <em class="replaceable"><code>NOTE:</code></em> If
      PCRE_DUPNAMES is set and there are duplicate names, the
      behaviour may not be what you want (see the next
      section).</p>

      <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Warning">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Warning]" src="../stylesheet/warning.png" /></td>

            <th align="left" rowspan="1" colspan="1">Warning</th>
          </tr>

          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>If the pattern uses the (?| feature to set up
              multiple subpatterns with the same number, as
              described in the section on duplicate subpattern
              numbers in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
              page, you cannot use names to distinguish the
              different subpatterns, because names are not included
              in the compiled code. The matching process uses only
              numbers. For this reason, the use of different names
              for subpatterns of the same number causes an error at
              compile time.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect22" name="pcreapi-3_sect22" shape="rect"> </a>

      <h2>DUPLICATE SUBPATTERN NAMES</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre_get_stringtable_entries(const pcre *<em class="parameter"><code>code</code></em>,</em></span>
<span class="emphasis"><em>     const char *<em class="parameter"><code>name</code></em>, char **<em class="parameter"><code>first</code></em>, char **<em class="parameter"><code>last</code></em>);</em></span>
</pre>
      </div>

      <p>When a pattern is compiled with the PCRE_DUPNAMES option,
      names for subpatterns are not required to be unique.
      (Duplicate names are always allowed for subpatterns with the
      same number, created by using the (?| feature. Indeed, if
      such subpatterns are named, they are required to use the same
      names.)</p>

      <p>Normally, patterns with duplicate names are such that in
      any one match, only one of the named subpatterns
      participates. An example is shown in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation.</p>

      <p>When duplicates are present, <code class="function">pcre_copy_named_substring</code>() and
      <code class="function">pcre_get_named_substring</code>()
      return the first substring corresponding to the given name
      that is set. If none are set, PCRE_ERROR_NOSUBSTRING (-7) is
      returned; no data is returned. The <code class="function">pcre_get_stringnumber</code>() function returns
      one of the numbers that are associated with the name, but it
      is not defined which it is.</p>

      <p>If you want to get full details of all captured substrings
      for a given name, you must use the <code class="function">pcre_get_stringtable_entries</code>() function.
      The first argument is the compiled pattern, and the second is
      the name. The third and fourth are pointers to variables
      which are updated by the function. After it has run, they
      point to the first and last entries in the name-to-number
      table for the given name. The function itself returns the
      length of each entry, or PCRE_ERROR_NOSUBSTRING (-7) if there
      are none. The format of the table is described above in the
      section entitled <span class="emphasis"><em>Information about
      a pattern</em></span> above. Given all the relevant entries
      for the name, you can extract each of their numbers, and
      hence the captured data, if any.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect23" name="pcreapi-3_sect23" shape="rect"> </a>

      <h2>FINDING ALL POSSIBLE MATCHES</h2>

      <p>The traditional matching function uses a similar algorithm
      to Perl, which stops when it finds the first match, starting
      at a given point in the subject. If you want to find all
      possible matches, or the longest possible match, consider
      using the alternative matching function (see below) instead.
      If you cannot use the alternative function, but still need to
      find all possible matches, you can kludge it up by making use
      of the callout facility, which is described in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>

      <p>What you have to do is to insert a callout right at the
      end of the pattern. When your callout function is called,
      extract and save the current matched substring. Then return
      1, which forces <code class="function">pcre_exec</code>() to
      backtrack and try other alternatives. Ultimately, when it
      runs out of matches, <code class="function">pcre_exec</code>() will yield
      PCRE_ERROR_NOMATCH.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect24" name="pcreapi-3_sect24" shape="rect"> </a>

      <h2>OBTAINING AN ESTIMATE OF STACK USAGE</h2>

      <p>Matching certain patterns using <code class="function">pcre_exec</code>() can use a lot of process stack,
      which in certain environments can be rather limited in size.
      Some users find it helpful to have an estimate of the amount
      of stack that is used by <code class="function">pcre_exec</code>(), to help them set recursion
      limits, as described in the <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a> documentation.
      The estimate that is output by <span class="command"><strong>pcretest</strong></span> when called with
      the <code class="option">−m</code> and <code class="option">−C</code> options is obtained by calling
      <code class="function">pcre_exec</code> with the values NULL,
      NULL, NULL, -999, and -999 for its first five arguments.</p>

      <p>Normally, if its first argument is NULL, <code class="function">pcre_exec</code>() immediately returns the
      negative error code PCRE_ERROR_NULL, but with this special
      combination of arguments, it returns instead a negative
      number whose absolute value is the approximate stack frame
      size in bytes. (A negative number is used so that it is clear
      that no match has happened.) The value is approximate because
      in some cases, recursive calls to <code class="function">pcre_exec</code>() occur when there are one or two
      additional variables on the stack.</p>

      <p>If PCRE has been compiled to use the heap instead of the
      stack for recursion, the value returned is the size of each
      block that is obtained from the heap.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect25" name="pcreapi-3_sect25" shape="rect"> </a>

      <h2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre_dfa_exec(const pcre *<em class="parameter"><code>code</code></em>, const pcre_extra *<em class="parameter"><code>extra</code></em>,</em></span>
<span class="emphasis"><em>     const char *<em class="parameter"><code>subject</code></em>, int <em class="parameter"><code>length</code></em>, int <em class="parameter"><code>startoffset</code></em>,</em></span>
<span class="emphasis"><em>     int <em class="parameter"><code>options</code></em>, int *<em class="parameter"><code>ovector</code></em>, int <em class="parameter"><code>ovecsize</code></em>,</em></span>
<span class="emphasis"><em>     int *<em class="parameter"><code>workspace</code></em>, int <em class="parameter"><code>wscount</code></em>);</em></span>
</pre>
      </div>

      <p>The function <code class="function">pcre_dfa_exec</code>()
      is called to match a subject string against a compiled
      pattern, using a matching algorithm that scans the subject
      string just once, and does not backtrack. This has different
      characteristics to the normal algorithm, and is not
      compatible with Perl. Some of the features of PCRE patterns
      are not supported. Nevertheless, there are times when this
      kind of matching can be useful. For a discussion of the two
      matching algorithms, and a list of features that <code class="function">pcre_dfa_exec</code>() does not support, see the
      <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>
      documentation.</p>

      <p>The arguments for the <code class="function">pcre_dfa_exec</code>() function are the same as
      for <code class="function">pcre_exec</code>(), plus two
      extras. The <em class="parameter"><code>ovector</code></em>
      argument is used in a different way, and this is described
      below. The other common arguments are used in the same way as
      for <code class="function">pcre_exec</code>(), so their
      description is not repeated here.</p>

      <p>The two additional arguments provide workspace for the
      function. The workspace vector should contain at least 20
      elements. It is used for keeping track of multiple paths
      through the pattern tree. More workspace will be needed for
      patterns and subjects where there are a lot of potential
      matches.</p>

      <p>Here is an example of a simple call to <code class="function">pcre_dfa_exec</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 int ovector[10];
 int wspace[20];
 rc = pcre_dfa_exec(
   re,             /* result of pcre_compile() */
   NULL,           /* we didn't study the pattern */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   ovector,        /* vector of integers for substring information */
   10,             /* number of elements (NOT size in bytes) */
   wspace,         /* working space vector */
   20);            /* number of elements (NOT size in bytes) */
</pre>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect26" name="pcreapi-3_sect26" shape="rect"> </a>

        <h3>Option bits for <code class="function">pcre_dfa_exec</code>()</h3>

        <p>The unused bits of the <em class="parameter"><code>options</code></em> argument for
        <code class="function">pcre_dfa_exec</code>() must be zero.
        The only bits that may be set are PCRE_ANCHORED,
        PCRE_NEWLINE_<code class="function">xxx</code>,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_NO_UTF8_CHECK,
        PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE, PCRE_NO_START_OPTIMIZE,
        PCRE_PARTIAL_HARD, PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST,
        and PCRE_DFA_RESTART. All but the last four of these are
        exactly the same as for <code class="function">pcre_exec</code>(), so their description is not
        repeated here.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_PARTIAL_HARD
 PCRE_PARTIAL_SOFT
</pre>
        </div>

        <p>These have the same general effect as they do for
        <code class="function">pcre_exec</code>(), but the details
        are slightly different. When PCRE_PARTIAL_HARD is set for
        <code class="function">pcre_dfa_exec</code>(), it returns
        PCRE_ERROR_PARTIAL if the end of the subject is reached and
        there is still at least one matching possibility that
        requires additional characters. This happens even if some
        complete matches have also been found. When
        PCRE_PARTIAL_SOFT is set, the return code
        PCRE_ERROR_NOMATCH is converted into PCRE_ERROR_PARTIAL if
        the end of the subject is reached, there have been no
        complete matches, but there is still at least one matching
        possibility. The portion of the string that was inspected
        when the longest partial match was found is set as the
        first matching string in both cases. There is a more
        detailed discussion of partial and multi-segment matching,
        with examples, in the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_DFA_SHORTEST
</pre>
        </div>

        <p>Setting the PCRE_DFA_SHORTEST option causes the matching
        algorithm to stop as soon as it has found one match.
        Because of the way the alternative algorithm works, this is
        necessarily the shortest possible match at the first
        possible matching point in the subject string.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_DFA_RESTART
</pre>
        </div>

        <p>When <code class="function">pcre_dfa_exec</code>()
        returns a partial match, it is possible to call it again,
        with additional subject characters, and have it continue
        with the same match. The PCRE_DFA_RESTART option requests
        this action; when it is set, the <em class="parameter"><code>workspace</code></em> and <em class="parameter"><code>wscount</code></em> options must
        reference the same vector as before because data about the
        match so far is left in them after a partial match. There
        is more discussion of this facility in the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect27" name="pcreapi-3_sect27" shape="rect"> </a>

        <h3>Successful returns from <code class="function">pcre_dfa_exec</code>()</h3>

        <p>When <code class="function">pcre_dfa_exec</code>()
        succeeds, it may have matched more than one substring in
        the subject. Note, however, that all the matches from one
        run of the function start at the same point in the subject.
        The shorter matches are all initial substrings of the
        longer matches. For example, if the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
&lt;.*&gt;
</pre>
        </div>

        <p>is matched against the string</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
This is &lt;something&gt; &lt;something else&gt; &lt;something further&gt; no more
</pre>
        </div>

        <p>the three matched strings are</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 &lt;something&gt;
 &lt;something&gt; &lt;something else&gt;
 &lt;something&gt; &lt;something else&gt; &lt;something further&gt;
</pre>
        </div>

        <p>On success, the yield of the function is a number
        greater than zero, which is the number of matched
        substrings. The substrings themselves are returned in
        <em class="parameter"><code>ovector</code></em>. Each
        string uses two elements; the first is the offset to the
        start, and the second is the offset to the end. In fact,
        all the strings have the same start offset. (Space could
        have been saved by giving this only once, but it was
        decided to retain some compatibility with the way
        <code class="function">pcre_exec</code>() returns data,
        even though the meaning of the strings is different.)</p>

        <p>The strings are returned in reverse order of length;
        that is, the longest matching string is given first. If
        there were too many matches to fit into <em class="parameter"><code>ovector</code></em>, the yield of the
        function is zero, and the vector is filled with the longest
        matches. Unlike <code class="function">pcre_exec</code>(),
        <code class="function">pcre_dfa_exec</code>() can use the
        entire <em class="parameter"><code>ovector</code></em> for
        returning matched strings.</p>

        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Note">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Note]" src="../stylesheet/note.png" /></td>

              <th align="left" rowspan="1" colspan="1">Note</th>
            </tr>

            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>PCRE's "auto-possessification" optimization
                usually applies to character repeats at the end of
                a pattern (as well as internally). For example, the
                pattern "a\d+" is compiled as if it were "a\d++"
                because there is no point even considering the
                possibility of backtracking into the repeated
                digits. For DFA matching, this means that only one
                possible match is found. If you really do want
                multiple matches in such cases, either use an
                ungreedy repeat ("a\d+?") or set the
                PCRE_NO_AUTO_POSSESS option when compiling.</p>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div class="refsect2">
        <a id="pcreapi-3_sect28" name="pcreapi-3_sect28" shape="rect"> </a>

        <h3>Error returns from <code class="function">pcre_dfa_exec</code>()</h3>

        <p>The <code class="function">pcre_dfa_exec</code>()
        function returns a negative number when it fails. Many of
        the errors are the same as for <code class="function">pcre_exec</code>(), and these are described
        above. There are in addition the following errors that are
        specific to <code class="function">pcre_dfa_exec</code>():</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UITEM      (-16)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() encounters an item in the
        pattern that it does not support, for instance, the use of
        \C or a back reference.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UCOND      (-17)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() encounters a condition
        item that uses a back reference for the condition, or a
        test for recursion in a specific group. These are not
        supported.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UMLIMIT    (-18)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() is called with an
        <em class="parameter"><code>extra</code></em> block that
        contains a setting of the <code class="function">match_limit</code> or <code class="function">match_limit_recursion</code> fields. This is not
        supported (these fields are meaningless for DFA
        matching).</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_WSSIZE     (-19)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() runs out of space in the
        <em class="parameter"><code>workspace</code></em>
        vector.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_RECURSE    (-20)
</pre>
        </div>

        <p>When a recursive subpattern is processed, the matching
        function calls itself recursively, using private vectors
        for <em class="parameter"><code>ovector</code></em> and
        <em class="parameter"><code>workspace</code></em>. This
        error is given if the output vector is not large enough.
        This should be extremely rare, as a vector of size 1000 is
        used.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_BADRESTART (-30)
</pre>
        </div>

        <p>When <code class="function">pcre_dfa_exec</code>() is
        called with the <code class="constant">PCRE_DFA_RESTART</code> option, some
        plausibility checks are made on the contents of the
        workspace, which should contain data about the previous
        partial match. If any of these checks fail, this error is
        given.</p>
      </div>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect29" name="pcreapi-3_sect29" shape="rect"> </a>

      <h2>SEE ALSO</h2>

      <p><a class="link" href="../htmlman3/pcre16.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre16</span>(3)</span></a>, <a class="link" href="../htmlman3/pcre32.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre32</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>,
      <span class="citerefentry"><span class="refentrytitle">pcrecpp(3)</span>(3)</span>, <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>, <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a>, <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>,
      <a class="link" href="../htmlman3/pcresample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcresample</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a>.</p>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect30" name="pcreapi-3_sect30" shape="rect"> </a>

      <h2>AUTHOR</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Philip Hazel
University Computing Service
Cambridge CB2 3QH, England.
</pre>
      </div>
    </div>

    <div class="refsect1">
      <a id="pcreapi-3_sect31" name="pcreapi-3_sect31" shape="rect"> </a>

      <h2>REVISION</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Last updated: 09 February 2014
Copyright (c) 1997-2014 University of Cambridge.
</pre>
      </div>
    </div>
  </div>
</body>
</html>
