<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <title>
   lber_decode(3) &mdash; Linux manual pages
  </title>
  <link href="../stylesheet/manpages.css" rel="stylesheet" type="text/css"/>
  <link href="../index.html" rel="home" title="lber_decode(3) &mdash; Linux manual pages"/>
  <script src="../stylesheet/manpages.js" type="text/javascript" xml:space="preserve">
  </script>
  <link href="../stylesheet/icon.gif" rel="icon" type="image/gif"/>
 </head>
 <body>
  <div class="refentry">
   <a id="lber-decode.3" name="lber-decode.3" shape="rect">
   </a>
   <div class="titlepage">
   </div>
   <div class="refnamediv">
    <h2>
     Name
    </h2>
    <p>
     ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf,
      ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa,
      ber_get_stringal, ber_get_stringbv, ber_get_null,
      ber_get_boolean, ber_get_bitstring, ber_first_element,
      ber_next_element &mdash; OpenLDAP LBER simplified Basic
      Encoding Rules library routines for decoding
    </p>
   </div>
   <div class="refsynopsisdiv">
    <h2>
     Synopsis
    </h2>
    <div class="funcsynopsis">
     <pre class="funcsynopsisinfo" xml:space="preserve">
#include &lt;lber.h&gt;
</pre>
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_next
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        Sockbuf *
        <var class="pdparam">
         sb
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         len
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_skip_tag
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         len
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_peek_tag
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         len
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_scanf
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        const char *
        <var class="pdparam">
         fmt
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        <var class="pdparam">
         ...
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_int
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_int_t *
        <var class="pdparam">
         num
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_enum
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_int_t *
        <var class="pdparam">
         num
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_stringb
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        char *
        <var class="pdparam">
         buf
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         len
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_stringa
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        char **
        <var class="pdparam">
         buf
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_stringal
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        struct berval **
        <var class="pdparam">
         bv
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_stringbv
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        struct berval *
        <var class="pdparam">
         bv
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        int
        <var class="pdparam">
         alloc
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_null
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_boolean
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_int_t *
        <var class="pdparam">
         bool
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_get_bitstringa
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        char **
        <var class="pdparam">
         buf
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         blen
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_first_element
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         len
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        char **
        <var class="pdparam">
         cookie
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
    <div class="funcsynopsis">
     <table border="0" class="funcprototype-table" style="cellspacing: 0; cellpadding: 0;" summary="Function synopsis">
      <tr>
       <td colspan="1" rowspan="1">
        <code class="funcdef">
         ber_tag_t
         <strong>
          ber_next_element
         </strong>
         (
        </code>
       </td>
       <td colspan="1" rowspan="1">
        BerElement *
        <var class="pdparam">
         ber
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        ber_len_t *
        <var class="pdparam">
         len
        </var>
        ,
       </td>
      </tr>
      <tr>
       <td colspan="1" rowspan="1">
        &nbsp;
       </td>
       <td colspan="1" rowspan="1">
        const char *
        <var class="pdparam">
         cookie
        </var>
        <code>
         )
        </code>
        ;
       </td>
      </tr>
     </table>
     <div class="funcprototype-spacer">
      &nbsp;
     </div>
    </div>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect1" name="lber-decode-3_sect1" shape="rect">
    </a>
    <h2>
     LIBRARY
    </h2>
    <p>
     OpenLDAP LBER (liblber, &minus;llber)
    </p>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect2" name="lber-decode-3_sect2" shape="rect">
    </a>
    <h2>
     DESCRIPTION
    </h2>
    <p>
     These routines provide a subroutine interface to a
      simplified implementation of the Basic Encoding Rules of
      ASN.1. The version of BER these routines support is the one
      defined for the LDAP protocol. The encoding rules are the
      same as BER, except that only definite form lengths are used,
      and bitstrings and octet strings are always encoded in
      primitive form. This man page describes the decoding routines
      in the lber library. See
     <a class="link" href="../htmlman3/lber-encode.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-encode
       </span>
       (3)
      </span>
     </a>
     for details
      on the corresponding encoding routines. Consult
     <a class="link" href="../htmlman3/lber-types.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-types
       </span>
       (3)
      </span>
     </a>
     for
      information about types, allocators, and deallocators.
    </p>
    <p>
     Normally, the only routines that need to be called by an
      application are
     <code class="function">
      ber_get_next
     </code>
     ()
      to get the next BER element and
     <code class="function">
      ber_scanf
     </code>
     () to do the actual decoding. In
      some cases,
     <code class="function">
      ber_peek_tag
     </code>
     () may
      also need to be called in normal usage. The other routines
      are provided for those applications that need more control
      than
     <code class="function">
      ber_scanf
     </code>
     () provides. In
      general, these routines return the tag of the element
      decoded, or LBER_ERROR if an error occurred.
    </p>
    <p>
     The
     <code class="function">
      ber_get_next
     </code>
     () routine
      is used to read the next BER element from the given Sockbuf,
     <em class="parameter">
      <code>
       sb
      </code>
     </em>
     . It strips off and
      returns the leading tag, strips off and returns the length of
      the entire element in
     <em class="parameter">
      <code>
       len
      </code>
     </em>
     , and sets up
     <em class="parameter">
      <code>
       ber
      </code>
     </em>
     for subsequent calls to
     <code class="function">
      ber_scanf
     </code>
     () et al to decode the
      element. See
     <a class="link" href="../htmlman3/lber-sockbuf.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-sockbuf
       </span>
       (3)
      </span>
     </a>
     for details
      of the Sockbuf implementation of the
     <em class="parameter">
      <code>
       sb
      </code>
     </em>
     parameter.
    </p>
    <p>
     The
     <code class="function">
      ber_scanf
     </code>
     () routine is
      used to decode a BER element in much the same way that
     <a class="link" href="../htmlman3/scanf.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        scanf
       </span>
       (3)
      </span>
     </a>
     works. It reads
      from
     <em class="parameter">
      <code>
       ber
      </code>
     </em>
     , a pointer
      to a BerElement such as returned by
     <code class="function">
      ber_get_next
     </code>
     (), interprets the bytes
      according to the format string
     <em class="parameter">
      <code>
       fmt
      </code>
     </em>
     , and stores the results in
      its additional arguments. The format string contains
      conversion specifications which are used to direct the
      interpretation of the BER element. The format string can
      contain the following characters.
    </p>
    <div class="blockquote">
     <blockquote class="blockquote">
      <div class="variablelist">
       <dl class="variablelist">
        <dt>
         <span class="term">
          <code class="constant">
           a
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Octet string. A char ** should be supplied.
                Memory is allocated, filled with the contents of
                the octet string, null-terminated, and returned in
                the parameter. The caller should free the returned
                string using
          <code class="function">
           ber_memfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           A
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Octet string. A variant of "
          <code class="literal">
           a
          </code>
          ". A char ** should be supplied.
                Memory is allocated, filled with the contents of
                the octet string, null-terminated, and returned in
                the parameter, unless a zero-length string would
                result; in that case, the arg is set to NULL. The
                caller should free the returned string using
          <code class="function">
           ber_memfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           s
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Octet string. A char * buffer should be
                supplied, followed by a pointer to a ber_len_t
                initialized to the size of the buffer. Upon return,
                the null-terminated octet string is put into the
                buffer, and the ber_len_t is set to the actual size
                of the octet string.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           O
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Octet string. A struct ber_val ** should be
                supplied, which upon return points to a dynamically
                allocated struct berval containing the octet string
                and its length. The caller should free the returned
                structure using
          <code class="function">
           ber_bvfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           o
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Octet string. A struct ber_val * should be
                supplied, which upon return contains the
                dynamically allocated octet string and its length.
                The caller should free the returned octet string
                using
          <code class="function">
           ber_memfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           m
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Octet string. A struct ber_val * should be
                supplied, which upon return contains the octet
                string and its length. The string resides in memory
                assigned to the BerElement, and must not be freed
                by the caller.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           b
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Boolean. A pointer to a ber_int_t should be
                supplied.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           e
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Enumeration. A pointer to a ber_int_t should be
                supplied.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           i
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Integer. A pointer to a ber_int_t should be
                supplied.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           B
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Bitstring. A char ** should be supplied which
                will point to the dynamically allocated bits,
                followed by a ber_len_t *, which will point to the
                length (in bits) of the bitstring returned.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           n
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Null. No parameter is required. The element is
                simply skipped if it is recognized.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           v
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Sequence of octet strings. A char *** should be
                supplied, which upon return points to a dynamically
                allocated null-terminated array of char *'s
                containing the octet strings. NULL is returned if
                the sequence is empty. The caller should free the
                returned array and octet strings using
          <code class="function">
           ber_memvfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           V
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Sequence of octet strings with lengths. A struct
                berval *** should be supplied, which upon return
                points to a dynamically allocated null-terminated
                array of struct berval *'s containing the octet
                strings and their lengths. NULL is returned if the
                sequence is empty. The caller should free the
                returned structures using
          <code class="function">
           ber_bvecfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           W
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Sequence of octet strings with lengths. A
                BerVarray * should be supplied, which upon return
                points to a dynamically allocated array of struct
                berval's containing the octet strings and their
                lengths. The array is terminated by a struct berval
                with a NULL bv_val string pointer. NULL is returned
                if the sequence is empty. The caller should free
                the returned structures using
          <code class="function">
           ber_bvarray_free
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           M
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Sequence of octet strings with lengths. This is
                a generalized form of the previous three formats. A
                void ** (ptr) should be supplied, followed by a
                ber_len_t * (len) and a ber_len_t (off). Upon
                return (ptr) will point to a dynamically allocated
                array whose elements are all of size (*len). A
                struct berval will be filled starting at offset
                (off) in each element. The strings in each struct
                berval reside in memory assigned to the BerElement
                and must not be freed by the caller. The array is
                terminated by a struct berval with a NULL bv_val
                string pointer. NULL is returned if the sequence is
                empty. The number of elements in the array is also
                stored in (*len) on return. The caller should free
                the returned array using
          <code class="function">
           ber_memfree
          </code>
          ().
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           l
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Length of the next element. A pointer to a
                ber_len_t should be supplied.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           t
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Tag of the next element. A pointer to a
                ber_tag_t should be supplied.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           T
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Skip element and return its tag. A pointer to a
                ber_tag_t should be supplied.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           x
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Skip element. The next element is skipped.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           {
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Begin sequence. No parameter is required. The
                initial sequence tag and length are skipped.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           }
          </code>
         </span>
        </dt>
        <dd>
         <p>
          End sequence. No parameter is required and no
                action is taken.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           [
          </code>
         </span>
        </dt>
        <dd>
         <p>
          Begin set. No parameter is required. The initial
                set tag and length are skipped.
         </p>
        </dd>
        <dt>
         <span class="term">
          <code class="constant">
           ]
          </code>
         </span>
        </dt>
        <dd>
         <p>
          End set. No parameter is required and no action
                is taken.
         </p>
        </dd>
       </dl>
      </div>
     </blockquote>
    </div>
    <p>
     The
     <code class="function">
      ber_get_int
     </code>
     () routine
      tries to interpret the next element as an integer, returning
      the result in
     <em class="parameter">
      <code>
       num
      </code>
     </em>
     .
      The tag of whatever it finds is returned on success,
      LBER_ERROR (&minus;1) on failure.
    </p>
    <p>
     The
     <code class="function">
      ber_get_stringb
     </code>
     ()
      routine is used to read an octet string into a preallocated
      buffer. The
     <em class="parameter">
      <code>
       len
      </code>
     </em>
     parameter should be initialized to the size of the buffer,
      and will contain the length of the octet string read upon
      return. The buffer should be big enough to take the octet
      string value plus a terminating NULL byte.
    </p>
    <p>
     The
     <code class="function">
      ber_get_stringa
     </code>
     ()
      routine is used to dynamically allocate space into which an
      octet string is read. The caller should free the returned
      string using
     <code class="function">
      ber_memfree
     </code>
     ().
    </p>
    <p>
     The
     <code class="function">
      ber_get_stringal
     </code>
     ()
      routine is used to dynamically allocate space into which an
      octet string and its length are read. It takes a struct
      berval **, and returns the result in this parameter. The
      caller should free the returned structure using
     <code class="function">
      ber_bvfree
     </code>
     ().
    </p>
    <p>
     The
     <code class="function">
      ber_get_stringbv
     </code>
     ()
      routine is used to read an octet string and its length into
      the provided struct berval *. If the
     <em class="parameter">
      <code>
       alloc
      </code>
     </em>
     parameter is zero, the
      string will reside in memory assigned to the BerElement, and
      must not be freed by the caller. If the
     <em class="parameter">
      <code>
       alloc
      </code>
     </em>
     parameter is non-zero,
      the string will be copied into dynamically allocated space
      which should be returned using
     <code class="function">
      ber_memfree
     </code>
     ().
    </p>
    <p>
     The
     <code class="function">
      ber_get_null
     </code>
     () routine
      is used to read a NULL element. It returns the tag of the
      element it skips over.
    </p>
    <p>
     The
     <code class="function">
      ber_get_boolean
     </code>
     ()
      routine is used to read a boolean value. It is called the
      same way that
     <code class="function">
      ber_get_int
     </code>
     () is
      called.
    </p>
    <p>
     The
     <code class="function">
      ber_get_enum
     </code>
     () routine
      is used to read a enumeration value. It is called the same
      way that
     <code class="function">
      ber_get_int
     </code>
     () is
      called.
    </p>
    <p>
     The
     <code class="function">
      ber_get_bitstringa
     </code>
     ()
      routine is used to read a bitstring value. It takes a char **
      which will hold the dynamically allocated bits, followed by
      an ber_len_t *, which will point to the length (in bits) of
      the bitstring returned. The caller should free the returned
      string using
     <code class="function">
      ber_memfree
     </code>
     ().
    </p>
    <p>
     The
     <code class="function">
      ber_first_element
     </code>
     ()
      routine is used to return the tag and length of the first
      element in a set or sequence. It also returns in
     <em class="parameter">
      <code>
       cookie
      </code>
     </em>
     a magic cookie parameter
      that should be passed to subsequent calls to
      ber_next_element(), which returns similar information.
    </p>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect3" name="lber-decode-3_sect3" shape="rect">
    </a>
    <h2>
     EXAMPLES
    </h2>
    <p>
     Assume the variable
     <em class="parameter">
      <code>
       ber
      </code>
     </em>
     contains a lightweight BER
      encoding of the following ASN.1 object:
    </p>
    <div class="informalexample">
     <pre class="programlisting" xml:space="preserve">
      AlmostASearchRequest := SEQUENCE {
          baseObject      DistinguishedName,
          scope           ENUMERATED {
              baseObject    (0),
              singleLevel   (1),
              wholeSubtree  (2)
          },
          derefAliases    ENUMERATED {
              neverDerefaliases   (0),
              derefInSearching    (1),
              derefFindingBaseObj (2),
              alwaysDerefAliases  (3)
          },
          sizelimit       INTEGER (0 .. 65535),
          timelimit       INTEGER (0 .. 65535),
          attrsOnly       BOOLEAN,
          attributes      SEQUENCE OF AttributeType
      }
</pre>
    </div>
    <p>
     The element can be decoded using
     <code class="function">
      ber_scanf
     </code>
     () as follows.
    </p>
    <div class="informalexample">
     <pre class="programlisting" xml:space="preserve">
      ber_int_t    scope, deref, size, time, attrsonly;
      char   *dn, **attrs;
      ber_tag_t tag;

      tag = ber_scanf( ber, "{aeeiib{v}}",
          &amp;dn, &amp;scope, &amp;deref,
          &amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

      if( tag == LBER_ERROR ) {
              /* error */
      } else {
              /* success */
      }

      ber_memfree( dn );
      ber_memvfree( attrs );
</pre>
    </div>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect4" name="lber-decode-3_sect4" shape="rect">
    </a>
    <h2>
     ERRORS
    </h2>
    <p>
     If an error occurs during decoding, generally these
      routines return LBER_ERROR ((ber_tag_t)&minus;1).
    </p>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect5" name="lber-decode-3_sect5" shape="rect">
    </a>
    <h2>
     NOTES
    </h2>
    <p>
     The return values for all of these functions are declared
      in the
     <code class="literal">
      &lt;
     </code>
     <code class="filename">
      lber.h
     </code>
     <code class="literal">
      &gt;
     </code>
     header file. Some routines may dynamically allocate memory
      which must be freed by the caller using supplied deallocation
      routines.
    </p>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect6" name="lber-decode-3_sect6" shape="rect">
    </a>
    <h2>
     SEE ALSO
    </h2>
    <p>
     <a class="link" href="../htmlman3/lber-encode.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-encode
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/lber-memory.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-memory
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/lber-sockbuf.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-sockbuf
       </span>
       (3)
      </span>
     </a>
     ,
     <a class="link" href="../htmlman3/lber-types.3.html" shape="rect" target="_top">
      <span class="citerefentry">
       <span class="refentrytitle">
        lber-types
       </span>
       (3)
      </span>
     </a>
    </p>
   </div>
   <div class="refsect1">
    <a id="lber-decode-3_sect7" name="lber-decode-3_sect7" shape="rect">
    </a>
    <h2>
     ACKNOWLEDGEMENTS
    </h2>
    <p>
     <span class="emphasis">
      <em>
       OpenLDAP Software
      </em>
     </span>
     is developed and maintained by The OpenLDAP Project
      &lt;
     <a class="literalurl" href="http://www.openldap.org/" shape="rect" target="_top">
      http://www.openldap.org/
     </a>
     &gt;.
     <span class="emphasis">
      <em>
       OpenLDAP Software
      </em>
     </span>
     is derived from
      University of Michigan LDAP 3.3 Release.
    </p>
   </div>
  </div>
 </body>
</html>
